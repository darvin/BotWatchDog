
<html>
   <head>
      <style type="text/css">
         .sikuli-code {
            font-size: 20px;
            font-family: "Osaka-mono", Monospace;
            line-height: 1.5em;
            display:table-cell;
            white-space: pre-wrap;       /* css-3 */
            white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
            white-space: -pre-wrap;      /* Opera 4-6 */
            white-space: -o-pre-wrap;    /* Opera 7 */
            word-wrap: break-word;       /* Internet Explorer 5.5+ */
            width: 99%;   /* remove horizontal scroll-bar when viewing in IE7 */
         }
         .sikuli-code img {
            vertical-align: middle;
            margin: 2px;
            border: 1px solid #ccc;
            padding: 2px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            -moz-box-shadow: 1px 1px 1px gray;
            -webkit-box-shadow: 1px 1px 2px gray;
         }
         .kw {
            color: blue;
         }
         .skw {
            color: rgb(63, 127, 127);
         }

         .str {
            color: rgb(128, 0, 0);
         }

         .dig {
            color: rgb(128, 64, 0);
         }

         .cmt {
            color: rgb(200, 0, 200);
         }

         h2 {
            display: inline;
            font-weight: normal;
         }

         .info {
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            margin-bottom: 20px;
            display: none;
         }

         a {
            color: #9D2900;
         }

         body {
            font-family: "Trebuchet MS", Arial, Sans-Serif;
         }

      </style>
   </head>
<body>
<div class="info">
<h2>bottle.sikuli</h2> <a href="bottle.zip">(Download this script)</a>
</div>
<pre class="sikuli-code">
<span class="cmt">#!/usr/bin/env python</span>
<span class="cmt"># -*- coding: utf-8 -*-</span>
<span class="str">"""
Bottle is a fast and simple micro-framework for small web applications. It
offers request dispatching (Routes) with URL parameter support, templates,
a built-in HTTP Server and adapters for many third party WSGI/HTTP-server and
template engines - all in a single file and with no dependencies other than the
Python Standard Library.

Homepage and documentation: http://bottlepy.org/

Copyright (c) 2015, Marcel Hellkamp.
License: MIT (see LICENSE for details)
"""</span>

<span class="kw">from</span> __future__ <span class="kw">import</span> with_statement
<span class="kw">import</span> sys

__author__ = <span class="str">'Marcel Hellkamp'</span>
__version__ = <span class="str">'0.13-dev'</span>
__license__ = <span class="str">'MIT'</span>

<span class="cmt">###############################################################################</span>
<span class="cmt"># Command-line interface ########################################################</span>
<span class="cmt">###############################################################################</span>
<span class="cmt"># INFO: Some server adapters need to monkey-patch std-lib modules before they</span>
<span class="cmt"># are imported. This is why some of the command-line handling is done here, but</span>
<span class="cmt"># the actual call to main() is at the end of the file.</span>


<span class="kw">def</span> _cli_parse(args):
    <span class="kw">from</span> optparse <span class="kw">import</span> OptionParser
    parser = OptionParser(
        usage=<span class="str">"usage: %prog [options] package.module:app"</span>)
    opt = parser.add_option
    opt(<span class="str">"--version"</span>, action=<span class="str">"store_true"</span>, help=<span class="str">"show version number."</span>)
    opt(<span class="str">"-b"</span>, <span class="str">"--bind"</span>, metavar=<span class="str">"ADDRESS"</span>, help=<span class="str">"bind socket to ADDRESS."</span>)
    opt(<span class="str">"-s"</span>, <span class="str">"--server"</span>, default=<span class="str">'wsgiref'</span>, help=<span class="str">"use SERVER as backend."</span>)
    opt(<span class="str">"-p"</span>, <span class="str">"--plugin"</span>, action=<span class="str">"append"</span>, help=<span class="str">"install additional plugin/s."</span>)
    opt(<span class="str">"-c"</span>, <span class="str">"--conf"</span>, action=<span class="str">"append"</span>, metavar=<span class="str">"FILE"</span>,
        help=<span class="str">"load config values from FILE."</span>)
    opt(<span class="str">"-C"</span>, <span class="str">"--param"</span>, action=<span class="str">"append"</span>, metavar=<span class="str">"NAME=VALUE"</span>,
        help=<span class="str">"override config values."</span>)
    opt(<span class="str">"--debug"</span>, action=<span class="str">"store_true"</span>, help=<span class="str">"start server in debug mode."</span>)
    opt(<span class="str">"--reload"</span>, action=<span class="str">"store_true"</span>, help=<span class="str">"auto-reload on file changes."</span>)
    opts, args = parser.parse_args(args[<span class="dig">1</span>:])

    <span class="kw">return</span> opts, args, parser


<span class="kw">def</span> _cli_patch(args):
    opts, _, _ = _cli_parse(args)
    <span class="kw">if</span> opts.server:
        <span class="kw">if</span> opts.server.startswith(<span class="str">'gevent'</span>):
            <span class="kw">import</span> gevent.monkey
            gevent.monkey.patch_all()
        <span class="kw">elif</span> opts.server.startswith(<span class="str">'eventlet'</span>):
            <span class="kw">import</span> eventlet
            eventlet.monkey_patch()


<span class="kw">if</span> __name__ == <span class="str">'__main__'</span>:
    _cli_patch(sys.argv)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Imports and Python 2/3 unification ###########################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">import</span> base64, cgi, email.utils, functools, hmac, imp, itertools, mimetypes,\
        os, re, tempfile, threading, time, warnings, hashlib

<span class="kw">from</span> types <span class="kw">import</span> FunctionType
<span class="kw">from</span> datetime <span class="kw">import</span> date <span class="kw">as</span> datedate, datetime, timedelta
<span class="kw">from</span> tempfile <span class="kw">import</span> TemporaryFile
<span class="kw">from</span> traceback <span class="kw">import</span> format_exc, print_exc
<span class="kw">from</span> unicodedata <span class="kw">import</span> normalize

<span class="cmt"># inspect.getargspec was removed in Python 3.6, use</span>
<span class="cmt"># Signature-based version where we can (Python 3.3+)</span>
<span class="kw">try</span>:
    <span class="kw">from</span> inspect <span class="kw">import</span> signature
    <span class="kw">def</span> getargspec(func):
        params = signature(func).parameters
        args, varargs, keywords, defaults = [], None, None, []
        <span class="kw">for</span> name, param <span class="kw">in</span> params.items():
            <span class="kw">if</span> param.kind == param.VAR_POSITIONAL:
                varargs = name
            <span class="kw">elif</span> param.kind == param.VAR_KEYWORD:
                keywords = name
            <span class="kw">else</span>:
                args.append(name)
                <span class="kw">if</span> param.default <span class="kw">is</span> <span class="kw">not</span> param.empty:
                    defaults.append(param.default)
        <span class="kw">return</span> (args, varargs, keywords, tuple(defaults) <span class="kw">or</span> None)
<span class="kw">except</span> ImportError:
    <span class="kw">try</span>:
        <span class="kw">from</span> inspect <span class="kw">import</span> getfullargspec
        <span class="kw">def</span> getargspec(func):
            spec = getfullargspec(func)
            kwargs = makelist(spec[<span class="dig">0</span>]) + makelist(spec.kwonlyargs)
            <span class="kw">return</span> kwargs, spec[<span class="dig">1</span>], spec[<span class="dig">2</span>], spec[<span class="dig">3</span>]
    <span class="kw">except</span> ImportError:
        <span class="kw">from</span> inspect <span class="kw">import</span> getargspec

<span class="kw">try</span>:
    <span class="kw">from</span> simplejson <span class="kw">import</span> dumps <span class="kw">as</span> json_dumps, loads <span class="kw">as</span> json_lds
<span class="kw">except</span> ImportError:  <span class="cmt"># pragma: no cover</span>
    <span class="kw">try</span>:
        <span class="kw">from</span> json <span class="kw">import</span> dumps <span class="kw">as</span> json_dumps, loads <span class="kw">as</span> json_lds
    <span class="kw">except</span> ImportError:
        <span class="kw">try</span>:
            <span class="kw">from</span> django.utils.simplejson <span class="kw">import</span> dumps <span class="kw">as</span> json_dumps, loads <span class="kw">as</span> json_lds
        <span class="kw">except</span> ImportError:

            <span class="kw">def</span> json_dumps(data):
                <span class="kw">raise</span> ImportError(
                    <span class="str">"JSON support requires Python 2.6 or simplejson."</span>)

            json_lds = json_dumps

<span class="cmt"># We now try to fix 2.5/2.6/3.1/3.2 incompatibilities.</span>
<span class="cmt"># It ain't pretty but it works... Sorry for the mess.</span>

py = sys.version_info
py3k = py &gt;= (<span class="dig">3</span>, <span class="dig">0</span>, <span class="dig">0</span>)
py25 = py &lt;  (<span class="dig">2</span>, <span class="dig">6</span>, <span class="dig">0</span>)
py31 = (<span class="dig">3</span>, <span class="dig">1</span>, <span class="dig">0</span>) &lt;= py &lt; (<span class="dig">3</span>, <span class="dig">2</span>, <span class="dig">0</span>)

<span class="cmt"># Workaround for the missing "as" keyword in py3k.</span>
<span class="kw">def</span> _e():
    <span class="kw">return</span> sys.exc_info()[<span class="dig">1</span>]

<span class="cmt"># Workaround for the "print is a keyword/function" Python 2/3 dilemma</span>
<span class="cmt"># and a fallback for mod_wsgi (resticts stdout/err attribute access)</span>
<span class="kw">try</span>:
    _stdout, _stderr = sys.stdout.write, sys.stderr.write
<span class="kw">except</span> IOError:
    _stdout = <span class="kw">lambda</span> x: sys.stdout.write(x)
    _stderr = <span class="kw">lambda</span> x: sys.stderr.write(x)

<span class="cmt"># Lots of stdlib and builtin differences.</span>
<span class="kw">if</span> py3k:
    <span class="kw">import</span> http.client <span class="kw">as</span> httplib
    <span class="kw">import</span> _thread <span class="kw">as</span> thread
    <span class="kw">from</span> urllib.parse <span class="kw">import</span> urljoin, SplitResult <span class="kw">as</span> UrlSplitResult
    <span class="kw">from</span> urllib.parse <span class="kw">import</span> urlencode, quote <span class="kw">as</span> urlquote, unquote <span class="kw">as</span> urlunquote
    urlunquote = functools.partial(urlunquote, encoding=<span class="str">'latin1'</span>)
    <span class="kw">from</span> http.cookies <span class="kw">import</span> SimpleCookie
    <span class="kw">from</span> collections <span class="kw">import</span> MutableMapping <span class="kw">as</span> DictMixin
    <span class="kw">import</span> pickle
    <span class="kw">from</span> io <span class="kw">import</span> BytesIO
    <span class="kw">from</span> configparser <span class="kw">import</span> ConfigParser, Error <span class="kw">as</span> ConfigParserError
    basestring = str
    unicode = str
    json_loads = <span class="kw">lambda</span> s: json_lds(touni(s))
    callable = <span class="kw">lambda</span> x: hasattr(x, <span class="str">'__call__'</span>)
    imap = map

    <span class="kw">def</span> _raise(*a):
        <span class="kw">raise</span> a[<span class="dig">0</span>](a[<span class="dig">1</span>]).with_traceback(a[<span class="dig">2</span>])
<span class="kw">else</span>:  <span class="cmt"># 2.x</span>
    <span class="kw">import</span> httplib
    <span class="kw">import</span> thread
    <span class="kw">from</span> urlparse <span class="kw">import</span> urljoin, SplitResult <span class="kw">as</span> UrlSplitResult
    <span class="kw">from</span> urllib <span class="kw">import</span> urlencode, quote <span class="kw">as</span> urlquote, unquote <span class="kw">as</span> urlunquote
    <span class="kw">from</span> Cookie <span class="kw">import</span> SimpleCookie
    <span class="kw">from</span> itertools <span class="kw">import</span> imap
    <span class="kw">import</span> cPickle <span class="kw">as</span> pickle
    <span class="kw">from</span> StringIO <span class="kw">import</span> StringIO <span class="kw">as</span> BytesIO
    <span class="kw">from</span> ConfigParser <span class="kw">import</span> SafeConfigParser <span class="kw">as</span> ConfigParser, \
                             Error <span class="kw">as</span> ConfigParserError
    <span class="kw">if</span> py25:
        <span class="kw">from</span> UserDict <span class="kw">import</span> DictMixin

        <span class="kw">def</span> next(it):
            <span class="kw">return</span> it.next()

        bytes = str
    <span class="kw">else</span>:  <span class="cmt"># 2.6, 2.7</span>
        <span class="kw">from</span> collections <span class="kw">import</span> MutableMapping <span class="kw">as</span> DictMixin
    unicode = unicode
    json_loads = json_lds
    eval(compile(<span class="str">'def _raise(*a): raise a[0], a[1], a[2]'</span>, <span class="str">'&lt;py3fix&gt;'</span>, <span class="str">'exec'</span>))

<span class="kw">if</span> py25 <span class="kw">or</span> py31:
    msg = <span class="str">"Python 2.5 and 3.1 support will be dropped in future versions of Bottle."</span>
    warnings.warn(msg, DeprecationWarning)

<span class="cmt"># Some helpers for string/byte handling</span>
<span class="kw">def</span> tob(s, enc=<span class="str">'utf8'</span>):
    <span class="kw">return</span> s.encode(enc) <span class="kw">if</span> isinstance(s, unicode) <span class="kw">else</span> bytes(s)


<span class="kw">def</span> touni(s, enc=<span class="str">'utf8'</span>, err=<span class="str">'strict'</span>):
    <span class="kw">if</span> isinstance(s, bytes):
        <span class="kw">return</span> s.decode(enc, err)
    <span class="kw">else</span>:
        <span class="kw">return</span> unicode(s <span class="kw">or</span> (<span class="str">""</span> <span class="kw">if</span> s <span class="kw">is</span> None <span class="kw">else</span> s))


tonat = touni <span class="kw">if</span> py3k <span class="kw">else</span> tob

<span class="cmt"># 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).</span>
<span class="cmt"># 3.1 needs a workaround.</span>
<span class="kw">if</span> py31:
    <span class="kw">from</span> io <span class="kw">import</span> TextIOWrapper

    <span class="kw">class</span> NCTextIOWrapper(TextIOWrapper):
        <span class="kw">def</span> close(self):
            <span class="kw">pass</span>  <span class="cmt"># Keep wrapped buffer open.</span>


<span class="cmt"># A bug in functools causes it to break if the wrapper is an instance method</span>
<span class="kw">def</span> update_wrapper(wrapper, wrapped, *a, **ka):
    <span class="kw">try</span>:
        functools.update_wrapper(wrapper, wrapped, *a, **ka)
    <span class="kw">except</span> AttributeError:
        <span class="kw">pass</span>

<span class="cmt"># These helpers are used at module level and need to be defined first.</span>
<span class="cmt"># And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.</span>


<span class="kw">def</span> depr(major, minor, cause, fix):
    text = <span class="str">"Warning: Use of deprecated feature or API. (Deprecated in Bottle-%d.%d)\n"</span>\
           <span class="str">"Cause: %s\n"</span>\
           <span class="str">"Fix: %s\n"</span> %  (major, minor, cause, fix)
    <span class="kw">if</span> DEBUG == <span class="str">'strict'</span>:
        <span class="kw">raise</span> DeprecationWarning(text)
    warnings.warn(text, DeprecationWarning, stacklevel=<span class="dig">3</span>)
    <span class="kw">return</span> DeprecationWarning(text)


<span class="kw">def</span> makelist(data):  <span class="cmt"># This is just too handy</span>
    <span class="kw">if</span> isinstance(data, (tuple, list, set, dict)):
        <span class="kw">return</span> list(data)
    <span class="kw">elif</span> data:
        <span class="kw">return</span> [data]
    <span class="kw">else</span>:
        <span class="kw">return</span> []


<span class="kw">class</span> DictProperty(object):
    <span class="str">""" Property that maps to a key in a local dict-like attribute. """</span>

    <span class="kw">def</span> __init__(self, attr, key=None, read_only=False):
        self.attr, self.key, self.read_only = attr, key, read_only

    <span class="kw">def</span> __call__(self, func):
        functools.update_wrapper(self, func, updated=[])
        self.getter, self.key = func, self.key <span class="kw">or</span> func.__name__
        <span class="kw">return</span> self

    <span class="kw">def</span> __get__(self, obj, cls):
        <span class="kw">if</span> obj <span class="kw">is</span> None: <span class="kw">return</span> self
        key, storage = self.key, getattr(obj, self.attr)
        <span class="kw">if</span> key <span class="kw">not</span> <span class="kw">in</span> storage: storage[key] = self.getter(obj)
        <span class="kw">return</span> storage[key]

    <span class="kw">def</span> __set__(self, obj, value):
        <span class="kw">if</span> self.read_only: <span class="kw">raise</span> AttributeError(<span class="str">"Read-Only property."</span>)
        getattr(obj, self.attr)[self.key] = value

    <span class="kw">def</span> __delete__(self, obj):
        <span class="kw">if</span> self.read_only: <span class="kw">raise</span> AttributeError(<span class="str">"Read-Only property."</span>)
        <span class="kw">del</span> getattr(obj, self.attr)[self.key]


<span class="kw">class</span> cached_property(object):
    <span class="str">""" A property that is only computed once per instance and then replaces
        itself with an ordinary attribute. Deleting the attribute resets the
        property. """</span>

    <span class="kw">def</span> __init__(self, func):
        self.__doc__ = getattr(func, <span class="str">'__doc__'</span>)
        self.func = func

    <span class="kw">def</span> __get__(self, obj, cls):
        <span class="kw">if</span> obj <span class="kw">is</span> None: <span class="kw">return</span> self
        value = obj.__dict__[self.func.__name__] = self.func(obj)
        <span class="kw">return</span> value


<span class="kw">class</span> lazy_attribute(object):
    <span class="str">""" A property that caches itself to the class object. """</span>

    <span class="kw">def</span> __init__(self, func):
        functools.update_wrapper(self, func, updated=[])
        self.getter = func

    <span class="kw">def</span> __get__(self, obj, cls):
        value = self.getter(cls)
        setattr(cls, self.__name__, value)
        <span class="kw">return</span> value

<span class="cmt">###############################################################################</span>
<span class="cmt"># Exceptions and Events ########################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> BottleException(Exception):
    <span class="str">""" A base class for exceptions used by bottle. """</span>
    <span class="kw">pass</span>

<span class="cmt">###############################################################################</span>
<span class="cmt"># Routing ######################################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> RouteError(BottleException):
    <span class="str">""" This is a base class for all routing related exceptions """</span>


<span class="kw">class</span> RouteReset(BottleException):
    <span class="str">""" If raised by a plugin or request handler, the route is reset and all
        plugins are re-applied. """</span>


<span class="kw">class</span> RouterUnknownModeError(RouteError):

    <span class="kw">pass</span>


<span class="kw">class</span> RouteSyntaxError(RouteError):
    <span class="str">""" The route parser found something not supported by this router. """</span>


<span class="kw">class</span> RouteBuildError(RouteError):
    <span class="str">""" The route could not be built. """</span>


<span class="kw">def</span> _re_flatten(p):
    <span class="str">""" Turn all capturing groups in a regular expression pattern into
        non-capturing groups. """</span>
    <span class="kw">if</span> <span class="str">'('</span> <span class="kw">not</span> <span class="kw">in</span> p:
        <span class="kw">return</span> p
    <span class="kw">return</span> re.sub(<span class="str">r'(\\*)(\(\?P&lt;[^&gt;]+&gt;|\((?!\?))'</span>, <span class="kw">lambda</span> m: m.group(<span class="dig">0</span>) <span class="kw">if</span>
                  len(m.group(<span class="dig">1</span>)) % <span class="dig">2</span> <span class="kw">else</span> m.group(<span class="dig">1</span>) + <span class="str">'(?:'</span>, p)


<span class="kw">class</span> Router(object):
    <span class="str">""" A Router is an ordered collection of route-&gt;target pairs. It is used to
        efficiently match WSGI requests against a number of routes and return
        the first target that satisfies the request. The target may be anything,
        usually a string, ID or callable object. A route consists of a path-rule
        and a HTTP method.

        The path-rule is either a static path (e.g. `/contact`) or a dynamic
        path that contains wildcards (e.g. `/wiki/&lt;page&gt;`). The wildcard syntax
        and details on the matching order are described in docs:`routing`.
    """</span>

    default_pattern = <span class="str">'[^/]+'</span>
    default_filter = <span class="str">'re'</span>

    <span class="cmt">#: The current CPython regexp implementation does not allow more</span>
    <span class="cmt">#: than 99 matching groups per regular expression.</span>
    _MAX_GROUPS_PER_PATTERN = <span class="dig">99</span>

    <span class="kw">def</span> __init__(self, strict=False):
        self.rules = []  <span class="cmt"># All rules in order</span>
        self._groups = {}  <span class="cmt"># index of regexes to find them in dyna_routes</span>
        self.builder = {}  <span class="cmt"># Data structure for the url builder</span>
        self.static = {}  <span class="cmt"># Search structure for static routes</span>
        self.dyna_routes = {}
        self.dyna_regexes = {}  <span class="cmt"># Search structure for dynamic routes</span>
        <span class="cmt">#: If true, static routes are no longer checked first.</span>
        self.strict_order = strict
        self.filters = {
            <span class="str">'re'</span>: <span class="kw">lambda</span> conf: (_re_flatten(conf <span class="kw">or</span> self.default_pattern),
                                None, None),
            <span class="str">'int'</span>: <span class="kw">lambda</span> conf: (<span class="str">r'-?\d+'</span>, int, <span class="kw">lambda</span> x: str(int(x))),
            <span class="str">'float'</span>: <span class="kw">lambda</span> conf: (<span class="str">r'-?[\d.]+'</span>, float, <span class="kw">lambda</span> x: str(float(x))),
            <span class="str">'path'</span>: <span class="kw">lambda</span> conf: (<span class="str">r'.+?'</span>, None, None)
        }

    <span class="kw">def</span> add_filter(self, name, func):
        <span class="str">""" Add a filter. The provided function is called with the configuration
        string as parameter and must return a (regexp, to_python, to_url) tuple.
        The first element is a string, the last two are callables or None. """</span>
        self.filters[name] = func

    rule_syntax = re.compile(<span class="str">'(\\\\*)'</span>
        <span class="str">'(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'</span>
          <span class="str">'|(?:&lt;([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'</span>
            <span class="str">'(?::((?:\\\\.|[^\\\\&gt;]+)+)?)?)?&gt;))'</span>)

    <span class="kw">def</span> _itertokens(self, rule):
        offset, prefix = <span class="dig">0</span>, <span class="str">''</span>
        <span class="kw">for</span> match <span class="kw">in</span> self.rule_syntax.finditer(rule):
            prefix += rule[offset:match.start()]
            g = match.groups()
            <span class="kw">if</span> g[<span class="dig">2</span>] <span class="kw">is</span> <span class="kw">not</span> None:
                depr(<span class="dig">0</span>, <span class="dig">13</span>, <span class="str">"Use of old route syntax."</span>,
                            <span class="str">"Use &lt;name&gt; instead of :name in routes."</span>)
            <span class="kw">if</span> len(g[<span class="dig">0</span>]) % <span class="dig">2</span>:  <span class="cmt"># Escaped wildcard</span>
                prefix += match.group(<span class="dig">0</span>)[len(g[<span class="dig">0</span>]):]
                offset = match.end()
                <span class="kw">continue</span>
            <span class="kw">if</span> prefix:
                <span class="kw">yield</span> prefix, None, None
            name, filtr, conf = g[<span class="dig">4</span>:<span class="dig">7</span>] <span class="kw">if</span> g[<span class="dig">2</span>] <span class="kw">is</span> None <span class="kw">else</span> g[<span class="dig">1</span>:<span class="dig">4</span>]
            <span class="kw">yield</span> name, filtr <span class="kw">or</span> <span class="str">'default'</span>, conf <span class="kw">or</span> None
            offset, prefix = match.end(), <span class="str">''</span>
        <span class="kw">if</span> offset &lt;= len(rule) <span class="kw">or</span> prefix:
            <span class="kw">yield</span> prefix + rule[offset:], None, None

    <span class="kw">def</span> add(self, rule, method, target, name=None):
        <span class="str">""" Add a new rule or replace the target for an existing rule. """</span>
        anons = <span class="dig">0</span>  <span class="cmt"># Number of anonymous wildcards found</span>
        keys = []  <span class="cmt"># Names of keys</span>
        pattern = <span class="str">''</span>  <span class="cmt"># Regular expression pattern with named groups</span>
        filters = []  <span class="cmt"># Lists of wildcard input filters</span>
        builder = []  <span class="cmt"># Data structure for the URL builder</span>
        is_static = True

        <span class="kw">for</span> key, mode, conf <span class="kw">in</span> self._itertokens(rule):
            <span class="kw">if</span> mode:
                is_static = False
                <span class="kw">if</span> mode == <span class="str">'default'</span>: mode = self.default_filter
                mask, in_filter, out_filter = self.filters[mode](conf)
                <span class="kw">if</span> <span class="kw">not</span> key:
                    pattern += <span class="str">'(?:%s)'</span> % mask
                    key = <span class="str">'anon%d'</span> % anons
                    anons += <span class="dig">1</span>
                <span class="kw">else</span>:
                    pattern += <span class="str">'(?P&lt;%s&gt;%s)'</span> % (key, mask)
                    keys.append(key)
                <span class="kw">if</span> in_filter: filters.append((key, in_filter))
                builder.append((key, out_filter <span class="kw">or</span> str))
            <span class="kw">elif</span> key:
                pattern += re.escape(key)
                builder.append((None, key))

        self.builder[rule] = builder
        <span class="kw">if</span> name: self.builder[name] = builder

        <span class="kw">if</span> is_static <span class="kw">and</span> <span class="kw">not</span> self.strict_order:
            self.static.setdefault(method, {})
            self.static[method][self.build(rule)] = (target, None)
            <span class="kw">return</span>

        <span class="kw">try</span>:
            re_pattern = re.compile(<span class="str">'^(%s)$'</span> % pattern)
            re_match = re_pattern.match
        <span class="kw">except</span> re.error:
            <span class="kw">raise</span> RouteSyntaxError(<span class="str">"Could not add Route: %s (%s)"</span> %
                                   (rule, _e()))

        <span class="kw">if</span> filters:

            <span class="kw">def</span> getargs(path):
                url_args = re_match(path).groupdict()
                <span class="kw">for</span> name, wildcard_filter <span class="kw">in</span> filters:
                    <span class="kw">try</span>:
                        url_args[name] = wildcard_filter(url_args[name])
                    <span class="kw">except</span> ValueError:
                        <span class="kw">raise</span> HTTPError(<span class="dig">400</span>, <span class="str">'Path has wrong format.'</span>)
                <span class="kw">return</span> url_args
        <span class="kw">elif</span> re_pattern.groupindex:

            <span class="kw">def</span> getargs(path):
                <span class="kw">return</span> re_match(path).groupdict()
        <span class="kw">else</span>:
            getargs = None

        flatpat = _re_flatten(pattern)
        whole_rule = (rule, flatpat, target, getargs)

        <span class="kw">if</span> (flatpat, method) <span class="kw">in</span> self._groups:
            <span class="kw">if</span> DEBUG:
                msg = <span class="str">'Route &lt;%s %s&gt; overwrites a previously defined route'</span>
                warnings.warn(msg % (method, rule), RuntimeWarning)
            self.dyna_routes[method][
                self._groups[flatpat, method]] = whole_rule
        <span class="kw">else</span>:
            self.dyna_routes.setdefault(method, []).append(whole_rule)
            self._groups[flatpat, method] = len(self.dyna_routes[method]) - <span class="dig">1</span>

        self._compile(method)

    <span class="kw">def</span> _compile(self, method):
        all_rules = self.dyna_routes[method]
        comborules = self.dyna_regexes[method] = []
        maxgroups = self._MAX_GROUPS_PER_PATTERN
        <span class="kw">for</span> x <span class="kw">in</span> range(<span class="dig">0</span>, len(all_rules), maxgroups):
            some = all_rules[x:x + maxgroups]
            combined = (flatpat <span class="kw">for</span> (_, flatpat, _, _) <span class="kw">in</span> some)
            combined = <span class="str">'|'</span>.join(<span class="str">'(^%s$)'</span> % flatpat <span class="kw">for</span> flatpat <span class="kw">in</span> combined)
            combined = re.compile(combined).match
            rules = [(target, getargs) <span class="kw">for</span> (_, _, target, getargs) <span class="kw">in</span> some]
            comborules.append((combined, rules))

    <span class="kw">def</span> build(self, _name, *anons, **query):
        <span class="str">""" Build an URL by filling the wildcards in a rule. """</span>
        builder = self.builder.get(_name)
        <span class="kw">if</span> <span class="kw">not</span> builder:
            <span class="kw">raise</span> RouteBuildError(<span class="str">"No route with that name."</span>, _name)
        <span class="kw">try</span>:
            <span class="kw">for</span> i, value <span class="kw">in</span> enumerate(anons):
                query[<span class="str">'anon%d'</span> % i] = value
            url = <span class="str">''</span>.join([f(query.pop(n)) <span class="kw">if</span> n <span class="kw">else</span> f <span class="kw">for</span> (n, f) <span class="kw">in</span> builder])
            <span class="kw">return</span> url <span class="kw">if</span> <span class="kw">not</span> query <span class="kw">else</span> url + <span class="str">'?'</span> + urlencode(query)
        <span class="kw">except</span> KeyError:
            <span class="kw">raise</span> RouteBuildError(<span class="str">'Missing URL argument: %r'</span> % _e().args[<span class="dig">0</span>])

    <span class="kw">def</span> match(self, environ):
        <span class="str">""" Return a (target, url_args) tuple or raise HTTPError(400/404/405). """</span>
        verb = environ[<span class="str">'REQUEST_METHOD'</span>].upper()
        path = environ[<span class="str">'PATH_INFO'</span>] <span class="kw">or</span> <span class="str">'/'</span>

        <span class="kw">if</span> verb == <span class="str">'HEAD'</span>:
            methods = [<span class="str">'PROXY'</span>, verb, <span class="str">'GET'</span>, <span class="str">'ANY'</span>]
        <span class="kw">else</span>:
            methods = [<span class="str">'PROXY'</span>, verb, <span class="str">'ANY'</span>]

        <span class="kw">for</span> method <span class="kw">in</span> methods:
            <span class="kw">if</span> method <span class="kw">in</span> self.static <span class="kw">and</span> path <span class="kw">in</span> self.static[method]:
                target, getargs = self.static[method][path]
                <span class="kw">return</span> target, getargs(path) <span class="kw">if</span> getargs <span class="kw">else</span> {}
            <span class="kw">elif</span> method <span class="kw">in</span> self.dyna_regexes:
                <span class="kw">for</span> combined, rules <span class="kw">in</span> self.dyna_regexes[method]:
                    match = combined(path)
                    <span class="kw">if</span> match:
                        target, getargs = rules[match.lastindex - <span class="dig">1</span>]
                        <span class="kw">return</span> target, getargs(path) <span class="kw">if</span> getargs <span class="kw">else</span> {}

        <span class="cmt"># No matching route found. Collect alternative methods for 405 response</span>
        allowed = set([])
        nocheck = set(methods)
        <span class="kw">for</span> method <span class="kw">in</span> set(self.static) - nocheck:
            <span class="kw">if</span> path <span class="kw">in</span> self.static[method]:
                allowed.add(verb)
        <span class="kw">for</span> method <span class="kw">in</span> set(self.dyna_regexes) - allowed - nocheck:
            <span class="kw">for</span> combined, rules <span class="kw">in</span> self.dyna_regexes[method]:
                match = combined(path)
                <span class="kw">if</span> match:
                    allowed.add(method)
        <span class="kw">if</span> allowed:
            allow_header = <span class="str">","</span>.join(sorted(allowed))
            <span class="kw">raise</span> HTTPError(<span class="dig">405</span>, <span class="str">"Method not allowed."</span>, Allow=allow_header)

        <span class="cmt"># No matching route and no alternative method found. We give up</span>
        <span class="kw">raise</span> HTTPError(<span class="dig">404</span>, <span class="str">"Not found: "</span> + repr(path))


<span class="kw">class</span> Route(object):
    <span class="str">""" This class wraps a route callback along with route specific metadata and
        configuration and applies Plugins on demand. It is also responsible for
        turing an URL path rule into a regular expression usable by the Router.
    """</span>

    <span class="kw">def</span> __init__(self, app, rule, method, callback,
                 name=None,
                 plugins=None,
                 skiplist=None, **config):
        <span class="cmt">#: The application this route is installed to.</span>
        self.app = app
        <span class="cmt">#: The path-rule string (e.g. ``/wiki/&lt;page&gt;``).</span>
        self.rule = rule
        <span class="cmt">#: The HTTP method as a string (e.g. ``GET``).</span>
        self.method = method
        <span class="cmt">#: The original callback with no plugins applied. Useful for introspection.</span>
        self.callback = callback
        <span class="cmt">#: The name of the route (if specified) or ``None``.</span>
        self.name = name <span class="kw">or</span> None
        <span class="cmt">#: A list of route-specific plugins (see :meth:`Bottle.route`).</span>
        self.plugins = plugins <span class="kw">or</span> []
        <span class="cmt">#: A list of plugins to not apply to this route (see :meth:`Bottle.route`).</span>
        self.skiplist = skiplist <span class="kw">or</span> []
        <span class="cmt">#: Additional keyword arguments passed to the :meth:`Bottle.route`</span>
        <span class="cmt">#: decorator are stored in this dictionary. Used for route-specific</span>
        <span class="cmt">#: plugin configuration and meta-data.</span>
        self.config = ConfigDict().load_dict(config)

    @cached_property
    <span class="kw">def</span> call(self):
        <span class="str">""" The route callback with all plugins applied. This property is
            created on demand and then cached to speed up subsequent requests."""</span>
        <span class="kw">return</span> self._make_callback()

    <span class="kw">def</span> reset(self):
        <span class="str">""" Forget any cached values. The next time :attr:`call` is accessed,
            all plugins are re-applied. """</span>
        self.__dict__.pop(<span class="str">'call'</span>, None)

    <span class="kw">def</span> prepare(self):
        <span class="str">""" Do all on-demand work immediately (useful for debugging)."""</span>
        self.call

    <span class="kw">def</span> all_plugins(self):
        <span class="str">""" Yield all Plugins affecting this route. """</span>
        unique = set()
        <span class="kw">for</span> p <span class="kw">in</span> reversed(self.app.plugins + self.plugins):
            <span class="kw">if</span> True <span class="kw">in</span> self.skiplist: <span class="kw">break</span>
            name = getattr(p, <span class="str">'name'</span>, False)
            <span class="kw">if</span> name <span class="kw">and</span> (name <span class="kw">in</span> self.skiplist <span class="kw">or</span> name <span class="kw">in</span> unique): <span class="kw">continue</span>
            <span class="kw">if</span> p <span class="kw">in</span> self.skiplist <span class="kw">or</span> <span class="skw">type</span>(p) <span class="kw">in</span> self.skiplist: <span class="kw">continue</span>
            <span class="kw">if</span> name: unique.add(name)
            <span class="kw">yield</span> p

    <span class="kw">def</span> _make_callback(self):
        callback = self.callback
        <span class="kw">for</span> plugin <span class="kw">in</span> self.all_plugins():
            <span class="kw">try</span>:
                <span class="kw">if</span> hasattr(plugin, <span class="str">'apply'</span>):
                    callback = plugin.apply(callback, self)
                <span class="kw">else</span>:
                    callback = plugin(callback)
            <span class="kw">except</span> RouteReset:  <span class="cmt"># Try again with changed configuration.</span>
                <span class="kw">return</span> self._make_callback()
            <span class="kw">if</span> <span class="kw">not</span> callback <span class="kw">is</span> self.callback:
                update_wrapper(callback, self.callback)
        <span class="kw">return</span> callback

    <span class="kw">def</span> get_undecorated_callback(self):
        <span class="str">""" Return the callback. If the callback is a decorated function, try to
            recover the original function. """</span>
        func = self.callback
        func = getattr(func, <span class="str">'__func__'</span> <span class="kw">if</span> py3k <span class="kw">else</span> <span class="str">'im_func'</span>, func)
        closure_attr = <span class="str">'__closure__'</span> <span class="kw">if</span> py3k <span class="kw">else</span> <span class="str">'func_closure'</span>
        <span class="kw">while</span> hasattr(func, closure_attr) <span class="kw">and</span> getattr(func, closure_attr):
            attributes = getattr(func, closure_attr)
            func = attributes[<span class="dig">0</span>].cell_contents

            <span class="cmt"># in case of decorators with multiple arguments</span>
            <span class="kw">if</span> <span class="kw">not</span> isinstance(func, FunctionType):
                <span class="cmt"># pick first FunctionType instance from multiple arguments</span>
                func = filter(<span class="kw">lambda</span> x: isinstance(x, FunctionType),
                              map(<span class="kw">lambda</span> x: x.cell_contents, attributes))
                func = list(func)[<span class="dig">0</span>]  <span class="cmt"># py3 support</span>
        <span class="kw">return</span> func

    <span class="kw">def</span> get_callback_args(self):
        <span class="str">""" Return a list of argument names the callback (most likely) accepts
            as keyword arguments. If the callback is a decorated function, try
            to recover the original function before inspection. """</span>
        <span class="kw">return</span> getargspec(self.get_undecorated_callback())[<span class="dig">0</span>]

    <span class="kw">def</span> get_config(self, key, default=None):
        <span class="str">""" Lookup a config field and return its value, first checking the
            route.config, then route.app.config."""</span>
        <span class="kw">for</span> conf <span class="kw">in</span> (self.config, self.app.config):
            <span class="kw">if</span> key <span class="kw">in</span> conf: <span class="kw">return</span> conf[key]
        <span class="kw">return</span> default

    <span class="kw">def</span> __repr__(self):
        cb = self.get_undecorated_callback()
        <span class="kw">return</span> <span class="str">'&lt;%s %r %r&gt;'</span> % (self.method, self.rule, cb)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Application Object ###########################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> Bottle(object):
    <span class="str">""" Each Bottle object represents a single, distinct web application and
        consists of routes, callbacks, plugins, resources and configuration.
        Instances are callable WSGI applications.

        :param catchall: If true (default), handle all exceptions. Turn off to
                         let debugging middleware handle exceptions.
    """</span>

    <span class="kw">def</span> __init__(self, catchall=True, autojson=True):
        <span class="cmt">#: A :class:`ConfigDict` for app specific configuration.</span>
        self.config = ConfigDict()
        self.config._add_change_listener(functools.partial(self.trigger_hook, <span class="str">'config'</span>))
        self.config.meta_set(<span class="str">'autojson'</span>, <span class="str">'validate'</span>, bool)
        self.config.meta_set(<span class="str">'catchall'</span>, <span class="str">'validate'</span>, bool)
        self.config[<span class="str">'catchall'</span>] = catchall
        self.config[<span class="str">'autojson'</span>] = autojson

        self._mounts = []

        <span class="cmt">#: A :class:`ResourceManager` for application files</span>
        self.resources = ResourceManager()

        self.routes = []  <span class="cmt"># List of installed :class:`Route` instances.</span>
        self.router = Router()  <span class="cmt"># Maps requests to :class:`Route` instances.</span>
        self.error_handler = {}

        <span class="cmt"># Core plugins</span>
        self.plugins = []  <span class="cmt"># List of installed plugins.</span>
        <span class="kw">if</span> self.config[<span class="str">'autojson'</span>]:
            self.install(JSONPlugin())
        self.install(TemplatePlugin())

    <span class="cmt">#: If true, most exceptions are caught and returned as :exc:`HTTPError`</span>
    catchall = DictProperty(<span class="str">'config'</span>, <span class="str">'catchall'</span>)

    __hook_names = <span class="str">'before_request'</span>, <span class="str">'after_request'</span>, <span class="str">'app_reset'</span>, <span class="str">'config'</span>
    __hook_reversed = <span class="str">'after_request'</span>

    @cached_property
    <span class="kw">def</span> _hooks(self):
        <span class="kw">return</span> dict((name, []) <span class="kw">for</span> name <span class="kw">in</span> self.__hook_names)

    <span class="kw">def</span> add_hook(self, name, func):
        <span class="str">""" Attach a callback to a hook. Three hooks are currently implemented:

            before_request
                Executed once before each request. The request context is
                available, but no routing has happened yet.
            after_request
                Executed once after each request regardless of its outcome.
            app_reset
                Called whenever :meth:`Bottle.reset` is called.
        """</span>
        <span class="kw">if</span> name <span class="kw">in</span> self.__hook_reversed:
            self._hooks[name].insert(<span class="dig">0</span>, func)
        <span class="kw">else</span>:
            self._hooks[name].append(func)

    <span class="kw">def</span> remove_hook(self, name, func):
        <span class="str">""" Remove a callback from a hook. """</span>
        <span class="kw">if</span> name <span class="kw">in</span> self._hooks <span class="kw">and</span> func <span class="kw">in</span> self._hooks[name]:
            self._hooks[name].remove(func)
            <span class="kw">return</span> True

    <span class="kw">def</span> trigger_hook(self, __name, *args, **kwargs):
        <span class="str">""" Trigger a hook and return a list of results. """</span>
        <span class="kw">return</span> [hook(*args, **kwargs) <span class="kw">for</span> hook <span class="kw">in</span> self._hooks[__name][:]]

    <span class="kw">def</span> hook(self, name):
        <span class="str">""" Return a decorator that attaches a callback to a hook. See
            :meth:`add_hook` for details."""</span>

        <span class="kw">def</span> decorator(func):
            self.add_hook(name, func)
            <span class="kw">return</span> func

        <span class="kw">return</span> decorator

    <span class="kw">def</span> _mount_wsgi(self, prefix, app, **options):
        segments = [p <span class="kw">for</span> p <span class="kw">in</span> prefix.split(<span class="str">'/'</span>) <span class="kw">if</span> p]
        <span class="kw">if</span> <span class="kw">not</span> segments:
            <span class="kw">raise</span> ValueError(<span class="str">'WSGI applications cannot be mounted to "/".'</span>)
        path_depth = len(segments)

        <span class="kw">def</span> mountpoint_wrapper():
            <span class="kw">try</span>:
                request.path_shift(path_depth)
                rs = HTTPResponse([])

                <span class="kw">def</span> start_response(status, headerlist, exc_info=None):
                    <span class="kw">if</span> exc_info:
                        _raise(*exc_info)
                    rs.status = status
                    <span class="kw">for</span> name, value <span class="kw">in</span> headerlist:
                        rs.add_header(name, value)
                    <span class="kw">return</span> rs.body.append

                body = app(request.environ, start_response)
                rs.body = itertools.chain(rs.body, body) <span class="kw">if</span> rs.body <span class="kw">else</span> body
                <span class="kw">return</span> rs
            <span class="kw">finally</span>:
                request.path_shift(-path_depth)

        options.setdefault(<span class="str">'skip'</span>, True)
        options.setdefault(<span class="str">'method'</span>, <span class="str">'PROXY'</span>)
        options.setdefault(<span class="str">'mountpoint'</span>, {<span class="str">'prefix'</span>: prefix, <span class="str">'target'</span>: app})
        options[<span class="str">'callback'</span>] = mountpoint_wrapper

        self.route(<span class="str">'/%s/&lt;:re:.*&gt;'</span> % <span class="str">'/'</span>.join(segments), **options)
        <span class="kw">if</span> <span class="kw">not</span> prefix.endswith(<span class="str">'/'</span>):
            self.route(<span class="str">'/'</span> + <span class="str">'/'</span>.join(segments), **options)

    <span class="kw">def</span> _mount_app(self, prefix, app, **options):
        <span class="kw">if</span> app <span class="kw">in</span> self._mounts <span class="kw">or</span> <span class="str">'_mount.app'</span> <span class="kw">in</span> app.config:
            depr(<span class="dig">0</span>, <span class="dig">13</span>, <span class="str">"Application mounted multiple times. Falling back to WSGI mount."</span>,
                 <span class="str">"Clone application before mounting to a different location."</span>)
            <span class="kw">return</span> self._mount_wsgi(prefix, app, **options)

        <span class="kw">if</span> options:
            depr(<span class="dig">0</span>, <span class="dig">13</span>, <span class="str">"Unsupported mount options. Falling back to WSGI mount."</span>,
                 <span class="str">"Do not specify any route options when mounting bottle application."</span>)
            <span class="kw">return</span> self._mount_wsgi(prefix, app, **options)

        <span class="kw">if</span> <span class="kw">not</span> prefix.endswith(<span class="str">"/"</span>):
            depr(<span class="dig">0</span>, <span class="dig">13</span>, <span class="str">"Prefix must end in '/'. Falling back to WSGI mount."</span>,
                 <span class="str">"Consider adding an explicit redirect from '/prefix' to '/prefix/' in the parent application."</span>)
            <span class="kw">return</span> self._mount_wsgi(prefix, app, **options)

        self._mounts.append(app)
        app.config[<span class="str">'_mount.prefix'</span>] = prefix
        app.config[<span class="str">'_mount.app'</span>] = self
        <span class="kw">for</span> route <span class="kw">in</span> app.routes:
            route.rule = prefix + route.rule.lstrip(<span class="str">'/'</span>)
            self.add_route(route)

    <span class="kw">def</span> mount(self, prefix, app, **options):
        <span class="str">""" Mount an application (:class:`Bottle` or plain WSGI) to a specific
            URL prefix. Example::

                parent_app.mount('/prefix/', child_app)

            :param prefix: path prefix or `mount-point`.
            :param app: an instance of :class:`Bottle` or a WSGI application.

            Plugins from the parent application are not applied to the routes
            of the mounted child application. If you need plugins in the child
            application, install them separately.

            While it is possible to use path wildcards within the prefix path
            (:class:`Bottle` childs only), it is highly discouraged.

            The prefix path must end with a slash. If you want to access the
            root of the child application via `/prefix` in addition to
            `/prefix/`, consider adding a route with a 307 redirect to the
            parent application.
        """</span>

        <span class="kw">if</span> <span class="kw">not</span> prefix.startswith(<span class="str">'/'</span>):
            <span class="kw">raise</span> ValueError(<span class="str">"Prefix must start with '/'"</span>)

        <span class="kw">if</span> isinstance(app, Bottle):
            <span class="kw">return</span> self._mount_app(prefix, app, **options)
        <span class="kw">else</span>:
            <span class="kw">return</span> self._mount_wsgi(prefix, app, **options)

    <span class="kw">def</span> merge(self, routes):
        <span class="str">""" Merge the routes of another :class:`Bottle` application or a list of
            :class:`Route` objects into this application. The routes keep their
            'owner', meaning that the :data:`Route.app` attribute is not
            changed. """</span>
        <span class="kw">if</span> isinstance(routes, Bottle):
            routes = routes.routes
        <span class="kw">for</span> route <span class="kw">in</span> routes:
            self.add_route(route)

    <span class="kw">def</span> install(self, plugin):
        <span class="str">""" Add a plugin to the list of plugins and prepare it for being
            applied to all routes of this application. A plugin may be a simple
            decorator or an object that implements the :class:`Plugin` API.
        """</span>
        <span class="kw">if</span> hasattr(plugin, <span class="str">'setup'</span>): plugin.setup(self)
        <span class="kw">if</span> <span class="kw">not</span> callable(plugin) <span class="kw">and</span> <span class="kw">not</span> hasattr(plugin, <span class="str">'apply'</span>):
            <span class="kw">raise</span> TypeError(<span class="str">"Plugins must be callable or implement .apply()"</span>)
        self.plugins.append(plugin)
        self.reset()
        <span class="kw">return</span> plugin

    <span class="kw">def</span> uninstall(self, plugin):
        <span class="str">""" Uninstall plugins. Pass an instance to remove a specific plugin, a type
            object to remove all plugins that match that type, a string to remove
            all plugins with a matching ``name`` attribute or ``True`` to remove all
            plugins. Return the list of removed plugins. """</span>
        removed, remove = [], plugin
        <span class="kw">for</span> i, plugin <span class="kw">in</span> list(enumerate(self.plugins))[::-<span class="dig">1</span>]:
            <span class="kw">if</span> remove <span class="kw">is</span> True <span class="kw">or</span> remove <span class="kw">is</span> plugin <span class="kw">or</span> remove <span class="kw">is</span> <span class="skw">type</span>(plugin) \
            <span class="kw">or</span> getattr(plugin, <span class="str">'name'</span>, True) == remove:
                removed.append(plugin)
                <span class="kw">del</span> self.plugins[i]
                <span class="kw">if</span> hasattr(plugin, <span class="str">'close'</span>): plugin.close()
        <span class="kw">if</span> removed: self.reset()
        <span class="kw">return</span> removed

    <span class="kw">def</span> reset(self, route=None):
        <span class="str">""" Reset all routes (force plugins to be re-applied) and clear all
            caches. If an ID or route object is given, only that specific route
            is affected. """</span>
        <span class="kw">if</span> route <span class="kw">is</span> None: routes = self.routes
        <span class="kw">elif</span> isinstance(route, Route): routes = [route]
        <span class="kw">else</span>: routes = [self.routes[route]]
        <span class="kw">for</span> route <span class="kw">in</span> routes:
            route.reset()
        <span class="kw">if</span> DEBUG:
            <span class="kw">for</span> route <span class="kw">in</span> routes:
                route.prepare()
        self.trigger_hook(<span class="str">'app_reset'</span>)

    <span class="kw">def</span> close(self):
        <span class="str">""" Close the application and all installed plugins. """</span>
        <span class="kw">for</span> plugin <span class="kw">in</span> self.plugins:
            <span class="kw">if</span> hasattr(plugin, <span class="str">'close'</span>): plugin.close()

    <span class="kw">def</span> run(self, **kwargs):
        <span class="str">""" Calls :func:`run` with the same parameters. """</span>
        run(self, **kwargs)

    <span class="kw">def</span> match(self, environ):
        <span class="str">""" Search for a matching route and return a (:class:`Route` , urlargs)
            tuple. The second value is a dictionary with parameters extracted
            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match."""</span>
        <span class="kw">return</span> self.router.match(environ)

    <span class="kw">def</span> get_url(self, routename, **kargs):
        <span class="str">""" Return a string that matches a named route """</span>
        scriptname = request.environ.get(<span class="str">'SCRIPT_NAME'</span>, <span class="str">''</span>).strip(<span class="str">'/'</span>) + <span class="str">'/'</span>
        location = self.router.build(routename, **kargs).lstrip(<span class="str">'/'</span>)
        <span class="kw">return</span> urljoin(urljoin(<span class="str">'/'</span>, scriptname), location)

    <span class="kw">def</span> add_route(self, route):
        <span class="str">""" Add a route object, but do not change the :data:`Route.app`
            attribute."""</span>
        self.routes.append(route)
        self.router.add(route.rule, route.method, route, name=route.name)
        <span class="kw">if</span> DEBUG: route.prepare()

    <span class="kw">def</span> route(self,
              path=None,
              method=<span class="str">'GET'</span>,
              callback=None,
              name=None,
              apply=None,
              skip=None, **config):
        <span class="str">""" A decorator to bind a function to a request URL. Example::

                @app.route('/hello/&lt;name&gt;')
                def hello(name):
                    return 'Hello %s' % name

            The ``&lt;name&gt;`` part is a wildcard. See :class:`Router` for syntax
            details.

            :param path: Request path or a list of paths to listen to. If no
              path is specified, it is automatically generated from the
              signature of the function.
            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of
              methods to listen to. (default: `GET`)
            :param callback: An optional shortcut to avoid the decorator
              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``
            :param name: The name for this route. (default: None)
            :param apply: A decorator or plugin or a list of plugins. These are
              applied to the route callback in addition to installed plugins.
            :param skip: A list of plugins, plugin classes or names. Matching
              plugins are not installed to this route. ``True`` skips all.

            Any additional keyword arguments are stored as route-specific
            configuration and passed to plugins (see :meth:`Plugin.apply`).
        """</span>
        <span class="kw">if</span> callable(path): path, callback = None, path
        plugins = makelist(apply)
        skiplist = makelist(skip)

        <span class="kw">def</span> decorator(callback):
            <span class="kw">if</span> isinstance(callback, basestring): callback = load(callback)
            <span class="kw">for</span> rule <span class="kw">in</span> makelist(path) <span class="kw">or</span> yieldroutes(callback):
                <span class="kw">for</span> verb <span class="kw">in</span> makelist(method):
                    verb = verb.upper()
                    route = Route(self, rule, verb, callback,
                                  name=name,
                                  plugins=plugins,
                                  skiplist=skiplist, **config)
                    self.add_route(route)
            <span class="kw">return</span> callback

        <span class="kw">return</span> decorator(callback) <span class="kw">if</span> callback <span class="kw">else</span> decorator

    <span class="kw">def</span> get(self, path=None, method=<span class="str">'GET'</span>, **options):
        <span class="str">""" Equals :meth:`route`. """</span>
        <span class="kw">return</span> self.route(path, method, **options)

    <span class="kw">def</span> post(self, path=None, method=<span class="str">'POST'</span>, **options):
        <span class="str">""" Equals :meth:`route` with a ``POST`` method parameter. """</span>
        <span class="kw">return</span> self.route(path, method, **options)

    <span class="kw">def</span> put(self, path=None, method=<span class="str">'PUT'</span>, **options):
        <span class="str">""" Equals :meth:`route` with a ``PUT`` method parameter. """</span>
        <span class="kw">return</span> self.route(path, method, **options)

    <span class="kw">def</span> delete(self, path=None, method=<span class="str">'DELETE'</span>, **options):
        <span class="str">""" Equals :meth:`route` with a ``DELETE`` method parameter. """</span>
        <span class="kw">return</span> self.route(path, method, **options)

    <span class="kw">def</span> patch(self, path=None, method=<span class="str">'PATCH'</span>, **options):
        <span class="str">""" Equals :meth:`route` with a ``PATCH`` method parameter. """</span>
        <span class="kw">return</span> self.route(path, method, **options)

    <span class="kw">def</span> error(self, code=<span class="dig">500</span>):
        <span class="str">""" Decorator: Register an output handler for a HTTP error code"""</span>

        <span class="kw">def</span> wrapper(handler):
            self.error_handler[int(code)] = handler
            <span class="kw">return</span> handler

        <span class="kw">return</span> wrapper

    <span class="kw">def</span> default_error_handler(self, res):
        <span class="kw">return</span> tob(template(ERROR_PAGE_TEMPLATE, e=res))

    <span class="kw">def</span> _handle(self, environ):
        path = environ[<span class="str">'bottle.raw_path'</span>] = environ[<span class="str">'PATH_INFO'</span>]
        <span class="kw">if</span> py3k:
            environ[<span class="str">'PATH_INFO'</span>] = path.encode(<span class="str">'latin1'</span>).decode(<span class="str">'utf8'</span>, <span class="str">'ignore'</span>)

        <span class="kw">def</span> _inner_handle():
            <span class="cmt"># Maybe pass variables as locals for better performance? </span>
            <span class="kw">try</span>:
                route, args = self.router.match(environ)
                environ[<span class="str">'route.handle'</span>] = route
                environ[<span class="str">'bottle.route'</span>] = route
                environ[<span class="str">'route.url_args'</span>] = args
                <span class="kw">return</span> route.call(**args)
            <span class="kw">except</span> HTTPResponse:
                <span class="kw">return</span> _e()
            <span class="kw">except</span> RouteReset:
                route.reset()
                <span class="kw">return</span> _inner_handle()
            <span class="kw">except</span> (KeyboardInterrupt, SystemExit, MemoryError):
                <span class="kw">raise</span>
            <span class="kw">except</span> Exception:
                <span class="kw">if</span> <span class="kw">not</span> self.catchall: <span class="kw">raise</span>
                stacktrace = format_exc()
                environ[<span class="str">'wsgi.errors'</span>].write(stacktrace)
                <span class="kw">return</span> HTTPError(<span class="dig">500</span>, <span class="str">"Internal Server Error"</span>, _e(), stacktrace)

        <span class="kw">try</span>:
            out = None
            environ[<span class="str">'bottle.app'</span>] = self
            request.bind(environ)
            response.bind()
            <span class="kw">try</span>:
                self.trigger_hook(<span class="str">'before_request'</span>)
            <span class="kw">except</span> HTTPResponse:
                <span class="kw">return</span>  _e()
            out = _inner_handle()
            <span class="kw">return</span> out
        <span class="kw">finally</span>:
            <span class="kw">if</span> isinstance(out, HTTPResponse):
                out.apply(response)
            self.trigger_hook(<span class="str">'after_request'</span>)

    <span class="kw">def</span> _cast(self, out, peek=None):
        <span class="str">""" Try to convert the parameter into something WSGI compatible and set
        correct HTTP headers when possible.
        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like,
        iterable of strings and iterable of unicodes
        """</span>

        <span class="cmt"># Empty output is done here</span>
        <span class="kw">if</span> <span class="kw">not</span> out:
            <span class="kw">if</span> <span class="str">'Content-Length'</span> <span class="kw">not</span> <span class="kw">in</span> response:
                response[<span class="str">'Content-Length'</span>] = <span class="dig">0</span>
            <span class="kw">return</span> []
        <span class="cmt"># Join lists of byte or unicode strings. Mixed lists are NOT supported</span>
        <span class="kw">if</span> isinstance(out, (tuple, list))\
        <span class="kw">and</span> isinstance(out[<span class="dig">0</span>], (bytes, unicode)):
            out = out[<span class="dig">0</span>][<span class="dig">0</span>:<span class="dig">0</span>].join(out)  <span class="cmt"># b'abc'[0:0] -&gt; b''</span>
        <span class="cmt"># Encode unicode strings</span>
        <span class="kw">if</span> isinstance(out, unicode):
            out = out.encode(response.charset)
        <span class="cmt"># Byte Strings are just returned</span>
        <span class="kw">if</span> isinstance(out, bytes):
            <span class="kw">if</span> <span class="str">'Content-Length'</span> <span class="kw">not</span> <span class="kw">in</span> response:
                response[<span class="str">'Content-Length'</span>] = len(out)
            <span class="kw">return</span> [out]
        <span class="cmt"># HTTPError or HTTPException (recursive, because they may wrap anything)</span>
        <span class="cmt"># TODO: Handle these explicitly in handle() or make them iterable.</span>
        <span class="kw">if</span> isinstance(out, HTTPError):
            out.apply(response)
            out = self.error_handler.get(out.status_code,
                                         self.default_error_handler)(out)
            <span class="kw">return</span> self._cast(out)
        <span class="kw">if</span> isinstance(out, HTTPResponse):
            out.apply(response)
            <span class="kw">return</span> self._cast(out.body)

        <span class="cmt"># File-like objects.</span>
        <span class="kw">if</span> hasattr(out, <span class="str">'read'</span>):
            <span class="kw">if</span> <span class="str">'wsgi.file_wrapper'</span> <span class="kw">in</span> request.environ:
                <span class="kw">return</span> request.environ[<span class="str">'wsgi.file_wrapper'</span>](out)
            <span class="kw">elif</span> hasattr(out, <span class="str">'close'</span>) <span class="kw">or</span> <span class="kw">not</span> hasattr(out, <span class="str">'__iter__'</span>):
                <span class="kw">return</span> WSGIFileWrapper(out)

        <span class="cmt"># Handle Iterables. We peek into them to detect their inner type.</span>
        <span class="kw">try</span>:
            iout = iter(out)
            first = next(iout)
            <span class="kw">while</span> <span class="kw">not</span> first:
                first = next(iout)
        <span class="kw">except</span> StopIteration:
            <span class="kw">return</span> self._cast(<span class="str">''</span>)
        <span class="kw">except</span> HTTPResponse:
            first = _e()
        <span class="kw">except</span> (KeyboardInterrupt, SystemExit, MemoryError):
            <span class="kw">raise</span>
        <span class="kw">except</span>:
            <span class="kw">if</span> <span class="kw">not</span> self.catchall: <span class="kw">raise</span>
            first = HTTPError(<span class="dig">500</span>, <span class="str">'Unhandled exception'</span>, _e(), format_exc())

        <span class="cmt"># These are the inner types allowed in iterator or generator objects.</span>
        <span class="kw">if</span> isinstance(first, HTTPResponse):
            <span class="kw">return</span> self._cast(first)
        <span class="kw">elif</span> isinstance(first, bytes):
            new_iter = itertools.chain([first], iout)
        <span class="kw">elif</span> isinstance(first, unicode):
            encoder = <span class="kw">lambda</span> x: x.encode(response.charset)
            new_iter = imap(encoder, itertools.chain([first], iout))
        <span class="kw">else</span>:
            msg = <span class="str">'Unsupported response type: %s'</span> % <span class="skw">type</span>(first)
            <span class="kw">return</span> self._cast(HTTPError(<span class="dig">500</span>, msg))
        <span class="kw">if</span> hasattr(out, <span class="str">'close'</span>):
            new_iter = _closeiter(new_iter, out.close)
        <span class="kw">return</span> new_iter

    <span class="kw">def</span> wsgi(self, environ, start_response):
        <span class="str">""" The bottle WSGI-interface. """</span>
        <span class="kw">try</span>:
            out = self._cast(self._handle(environ))
            <span class="cmt"># rfc2616 section 4.3</span>
            <span class="kw">if</span> response._status_code <span class="kw">in</span> (<span class="dig">100</span>, <span class="dig">101</span>, <span class="dig">204</span>, <span class="dig">304</span>)\
            <span class="kw">or</span> environ[<span class="str">'REQUEST_METHOD'</span>] == <span class="str">'HEAD'</span>:
                <span class="kw">if</span> hasattr(out, <span class="str">'close'</span>): out.close()
                out = []
            start_response(response._status_line, response.headerlist)
            <span class="kw">return</span> out
        <span class="kw">except</span> (KeyboardInterrupt, SystemExit, MemoryError):
            <span class="kw">raise</span>
        <span class="kw">except</span>:
            <span class="kw">if</span> <span class="kw">not</span> self.catchall: <span class="kw">raise</span>
            err = <span class="str">'&lt;h1&gt;Critical error while processing request: %s&lt;/h1&gt;'</span> \
                  % html_escape(environ.get(<span class="str">'PATH_INFO'</span>, <span class="str">'/'</span>))
            <span class="kw">if</span> DEBUG:
                err += <span class="str">'&lt;h2&gt;Error:&lt;/h2&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n'</span> \
                       <span class="str">'&lt;h2&gt;Traceback:&lt;/h2&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n'</span> \
                       % (html_escape(repr(_e())), html_escape(format_exc()))
            environ[<span class="str">'wsgi.errors'</span>].write(err)
            headers = [(<span class="str">'Content-Type'</span>, <span class="str">'text/html; charset=UTF-8'</span>)]
            start_response(<span class="str">'500 INTERNAL SERVER ERROR'</span>, headers, sys.exc_info())
            <span class="kw">return</span> [tob(err)]

    <span class="kw">def</span> __call__(self, environ, start_response):
        <span class="str">""" Each instance of :class:'Bottle' is a WSGI application. """</span>
        <span class="kw">return</span> self.wsgi(environ, start_response)

    <span class="kw">def</span> __enter__(self):
        <span class="str">""" Use this application as default for all module-level shortcuts. """</span>
        default_app.push(self)
        <span class="kw">return</span> self

    <span class="kw">def</span> __exit__(self, exc_type, exc_value, traceback):
        default_app.pop()

    <span class="kw">def</span> __setattr__(self, name, value):
        <span class="kw">if</span> name <span class="kw">in</span> self.__dict__:
            <span class="kw">raise</span> AttributeError(<span class="str">"Attribute %s already defined. Plugin conflict?"</span> % name)
        self.__dict__[name] = value


<span class="cmt">###############################################################################</span>
<span class="cmt"># HTTP and WSGI Tools ##########################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> BaseRequest(object):
    <span class="str">""" A wrapper for WSGI environment dictionaries that adds a lot of
        convenient access methods and properties. Most of them are read-only.

        Adding new attributes to a request actually adds them to the environ
        dictionary (as 'bottle.request.ext.&lt;name&gt;'). This is the recommended
        way to store and access request-specific data.
    """</span>

    __slots__ = (<span class="str">'environ'</span>, )

    <span class="cmt">#: Maximum size of memory buffer for :attr:`body` in bytes.</span>
    MEMFILE_MAX = <span class="dig">102400</span>

    <span class="kw">def</span> __init__(self, environ=None):
        <span class="str">""" Wrap a WSGI environ dictionary. """</span>
        <span class="cmt">#: The wrapped WSGI environ dictionary. This is the only real attribute.</span>
        <span class="cmt">#: All other attributes actually are read-only properties.</span>
        self.environ = {} <span class="kw">if</span> environ <span class="kw">is</span> None <span class="kw">else</span> environ
        self.environ[<span class="str">'bottle.request'</span>] = self

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.app'</span>, read_only=True)
    <span class="kw">def</span> app(self):
        <span class="str">""" Bottle application handling this request. """</span>
        <span class="kw">raise</span> RuntimeError(<span class="str">'This request is not connected to an application.'</span>)

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.route'</span>, read_only=True)
    <span class="kw">def</span> route(self):
        <span class="str">""" The bottle :class:`Route` object that matches this request. """</span>
        <span class="kw">raise</span> RuntimeError(<span class="str">'This request is not connected to a route.'</span>)

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'route.url_args'</span>, read_only=True)
    <span class="kw">def</span> url_args(self):
        <span class="str">""" The arguments extracted from the URL. """</span>
        <span class="kw">raise</span> RuntimeError(<span class="str">'This request is not connected to a route.'</span>)

    @property
    <span class="kw">def</span> path(self):
        <span class="str">""" The value of ``PATH_INFO`` with exactly one prefixed slash (to fix
            broken clients and avoid the "empty path" edge case). """</span>
        <span class="kw">return</span> <span class="str">'/'</span> + self.environ.get(<span class="str">'PATH_INFO'</span>, <span class="str">''</span>).lstrip(<span class="str">'/'</span>)

    @property
    <span class="kw">def</span> method(self):
        <span class="str">""" The ``REQUEST_METHOD`` value as an uppercase string. """</span>
        <span class="kw">return</span> self.environ.get(<span class="str">'REQUEST_METHOD'</span>, <span class="str">'GET'</span>).upper()

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.headers'</span>, read_only=True)
    <span class="kw">def</span> headers(self):
        <span class="str">""" A :class:`WSGIHeaderDict` that provides case-insensitive access to
            HTTP request headers. """</span>
        <span class="kw">return</span> WSGIHeaderDict(self.environ)

    <span class="kw">def</span> get_header(self, name, default=None):
        <span class="str">""" Return the value of a request header, or a given default value. """</span>
        <span class="kw">return</span> self.headers.get(name, default)

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.cookies'</span>, read_only=True)
    <span class="kw">def</span> cookies(self):
        <span class="str">""" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT
            decoded. Use :meth:`get_cookie` if you expect signed cookies. """</span>
        cookies = SimpleCookie(self.environ.get(<span class="str">'HTTP_COOKIE'</span>, <span class="str">''</span>)).values()
        <span class="kw">return</span> FormsDict((c.key, c.value) <span class="kw">for</span> c <span class="kw">in</span> cookies)

    <span class="kw">def</span> get_cookie(self, key, default=None, secret=None):
        <span class="str">""" Return the content of a cookie. To read a `Signed Cookie`, the
            `secret` must match the one used to create the cookie (see
            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing
            cookie or wrong signature), return a default value. """</span>
        value = self.cookies.get(key)
        <span class="kw">if</span> secret <span class="kw">and</span> value:
            dec = cookie_decode(value, secret)  <span class="cmt"># (key, value) tuple or None</span>
            <span class="kw">return</span> dec[<span class="dig">1</span>] <span class="kw">if</span> dec <span class="kw">and</span> dec[<span class="dig">0</span>] == key <span class="kw">else</span> default
        <span class="kw">return</span> value <span class="kw">or</span> default

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.query'</span>, read_only=True)
    <span class="kw">def</span> query(self):
        <span class="str">""" The :attr:`query_string` parsed into a :class:`FormsDict`. These
            values are sometimes called "URL arguments" or "GET parameters", but
            not to be confused with "URL wildcards" as they are provided by the
            :class:`Router`. """</span>
        get = self.environ[<span class="str">'bottle.get'</span>] = FormsDict()
        pairs = _parse_qsl(self.environ.get(<span class="str">'QUERY_STRING'</span>, <span class="str">''</span>))
        <span class="kw">for</span> key, value <span class="kw">in</span> pairs:
            get[key] = value
        <span class="kw">return</span> get

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.forms'</span>, read_only=True)
    <span class="kw">def</span> forms(self):
        <span class="str">""" Form values parsed from an `url-encoded` or `multipart/form-data`
            encoded POST or PUT request body. The result is returned as a
            :class:`FormsDict`. All keys and values are strings. File uploads
            are stored separately in :attr:`files`. """</span>
        forms = FormsDict()
        <span class="kw">for</span> name, item <span class="kw">in</span> self.POST.allitems():
            <span class="kw">if</span> <span class="kw">not</span> isinstance(item, FileUpload):
                forms[name] = item
        <span class="kw">return</span> forms

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.params'</span>, read_only=True)
    <span class="kw">def</span> params(self):
        <span class="str">""" A :class:`FormsDict` with the combined values of :attr:`query` and
            :attr:`forms`. File uploads are stored in :attr:`files`. """</span>
        params = FormsDict()
        <span class="kw">for</span> key, value <span class="kw">in</span> self.query.allitems():
            params[key] = value
        <span class="kw">for</span> key, value <span class="kw">in</span> self.forms.allitems():
            params[key] = value
        <span class="kw">return</span> params

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.files'</span>, read_only=True)
    <span class="kw">def</span> files(self):
        <span class="str">""" File uploads parsed from `multipart/form-data` encoded POST or PUT
            request body. The values are instances of :class:`FileUpload`.

        """</span>
        files = FormsDict()
        <span class="kw">for</span> name, item <span class="kw">in</span> self.POST.allitems():
            <span class="kw">if</span> isinstance(item, FileUpload):
                files[name] = item
        <span class="kw">return</span> files

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.json'</span>, read_only=True)
    <span class="kw">def</span> json(self):
        <span class="str">""" If the ``Content-Type`` header is ``application/json`` or
            ``application/json-rpc``, this property holds the parsed content 
            of the request body. Only requests smaller than :attr:`MEMFILE_MAX`
            are processed to avoid memory exhaustion.
            Invalid JSON raises a 400 error response.
        """</span>
        ctype = self.environ.get(<span class="str">'CONTENT_TYPE'</span>, <span class="str">''</span>).lower().split(<span class="str">';'</span>)[<span class="dig">0</span>]
        <span class="kw">if</span> ctype <span class="kw">in</span> (<span class="str">'application/json'</span>, <span class="str">'application/json-rpc'</span>):
            b = self._get_body_string()
            <span class="kw">if</span> <span class="kw">not</span> b:
                <span class="kw">return</span> None
            <span class="kw">try</span>:
                <span class="kw">return</span> json_loads(b)
            <span class="kw">except</span> (ValueError, TypeError):
                <span class="kw">raise</span> HTTPError(<span class="dig">400</span>, <span class="str">'Invalid JSON'</span>)
        <span class="kw">return</span> None

    <span class="kw">def</span> _iter_body(self, read, bufsize):
        maxread = max(<span class="dig">0</span>, self.content_length)
        <span class="kw">while</span> maxread:
            part = read(min(maxread, bufsize))
            <span class="kw">if</span> <span class="kw">not</span> part: <span class="kw">break</span>
            <span class="kw">yield</span> part
            maxread -= len(part)

    @staticmethod
    <span class="kw">def</span> _iter_chunked(read, bufsize):
        err = HTTPError(<span class="dig">400</span>, <span class="str">'Error while parsing chunked transfer body.'</span>)
        rn, sem, bs = tob(<span class="str">'\r\n'</span>), tob(<span class="str">';'</span>), tob(<span class="str">''</span>)
        <span class="kw">while</span> True:
            header = read(<span class="dig">1</span>)
            <span class="kw">while</span> header[-<span class="dig">2</span>:] != rn:
                c = read(<span class="dig">1</span>)
                header += c
                <span class="kw">if</span> <span class="kw">not</span> c: <span class="kw">raise</span> err
                <span class="kw">if</span> len(header) &gt; bufsize: <span class="kw">raise</span> err
            size, _, _ = header.partition(sem)
            <span class="kw">try</span>:
                maxread = int(tonat(size.strip()), <span class="dig">16</span>)
            <span class="kw">except</span> ValueError:
                <span class="kw">raise</span> err
            <span class="kw">if</span> maxread == <span class="dig">0</span>: <span class="kw">break</span>
            buff = bs
            <span class="kw">while</span> maxread &gt; <span class="dig">0</span>:
                <span class="kw">if</span> <span class="kw">not</span> buff:
                    buff = read(min(maxread, bufsize))
                part, buff = buff[:maxread], buff[maxread:]
                <span class="kw">if</span> <span class="kw">not</span> part: <span class="kw">raise</span> err
                <span class="kw">yield</span> part
                maxread -= len(part)
            <span class="kw">if</span> read(<span class="dig">2</span>) != rn:
                <span class="kw">raise</span> err

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.body'</span>, read_only=True)
    <span class="kw">def</span> _body(self):
        <span class="kw">try</span>:
            read_func = self.environ[<span class="str">'wsgi.input'</span>].read
        <span class="kw">except</span> KeyError:
            self.environ[<span class="str">'wsgi.input'</span>] = BytesIO()
            <span class="kw">return</span> self.environ[<span class="str">'wsgi.input'</span>]
        body_iter = self._iter_chunked <span class="kw">if</span> self.chunked <span class="kw">else</span> self._iter_body
        body, body_size, is_temp_file = BytesIO(), <span class="dig">0</span>, False
        <span class="kw">for</span> part <span class="kw">in</span> body_iter(read_func, self.MEMFILE_MAX):
            body.write(part)
            body_size += len(part)
            <span class="kw">if</span> <span class="kw">not</span> is_temp_file <span class="kw">and</span> body_size &gt; self.MEMFILE_MAX:
                body, tmp = TemporaryFile(mode=<span class="str">'w+b'</span>), body
                body.write(tmp.getvalue())
                <span class="kw">del</span> tmp
                is_temp_file = True
        self.environ[<span class="str">'wsgi.input'</span>] = body
        body.seek(<span class="dig">0</span>)
        <span class="kw">return</span> body

    <span class="kw">def</span> _get_body_string(self):
        <span class="str">""" read body until content-length or MEMFILE_MAX into a string. Raise
            HTTPError(413) on requests that are to large. """</span>
        clen = self.content_length
        <span class="kw">if</span> clen &gt; self.MEMFILE_MAX:
            <span class="kw">raise</span> HTTPError(<span class="dig">413</span>, <span class="str">'Request entity too large'</span>)
        <span class="kw">if</span> clen &lt; <span class="dig">0</span>: clen = self.MEMFILE_MAX + <span class="dig">1</span>
        data = self.body.read(clen)
        <span class="kw">if</span> len(data) &gt; self.MEMFILE_MAX:  <span class="cmt"># Fail fast</span>
            <span class="kw">raise</span> HTTPError(<span class="dig">413</span>, <span class="str">'Request entity too large'</span>)
        <span class="kw">return</span> data

    @property
    <span class="kw">def</span> body(self):
        <span class="str">""" The HTTP request body as a seek-able file-like object. Depending on
            :attr:`MEMFILE_MAX`, this is either a temporary file or a
            :class:`io.BytesIO` instance. Accessing this property for the first
            time reads and replaces the ``wsgi.input`` environ variable.
            Subsequent accesses just do a `seek(0)` on the file object. """</span>
        self._body.seek(<span class="dig">0</span>)
        <span class="kw">return</span> self._body

    @property
    <span class="kw">def</span> chunked(self):
        <span class="str">""" True if Chunked transfer encoding was. """</span>
        <span class="kw">return</span> <span class="str">'chunked'</span> <span class="kw">in</span> self.environ.get(
            <span class="str">'HTTP_TRANSFER_ENCODING'</span>, <span class="str">''</span>).lower()

    <span class="cmt">#: An alias for :attr:`query`.</span>
    GET = query

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.post'</span>, read_only=True)
    <span class="kw">def</span> POST(self):
        <span class="str">""" The values of :attr:`forms` and :attr:`files` combined into a single
            :class:`FormsDict`. Values are either strings (form values) or
            instances of :class:`cgi.FieldStorage` (file uploads).
        """</span>
        post = FormsDict()
        <span class="cmt"># We default to application/x-www-form-urlencoded for everything that</span>
        <span class="cmt"># is not multipart and take the fast path (also: 3.1 workaround)</span>
        <span class="kw">if</span> <span class="kw">not</span> self.content_type.startswith(<span class="str">'multipart/'</span>):
            pairs = _parse_qsl(tonat(self._get_body_string(), <span class="str">'latin1'</span>))
            <span class="kw">for</span> key, value <span class="kw">in</span> pairs:
                post[key] = value
            <span class="kw">return</span> post

        safe_env = {<span class="str">'QUERY_STRING'</span>: <span class="str">''</span>}  <span class="cmt"># Build a safe environment for cgi</span>
        <span class="kw">for</span> key <span class="kw">in</span> (<span class="str">'REQUEST_METHOD'</span>, <span class="str">'CONTENT_TYPE'</span>, <span class="str">'CONTENT_LENGTH'</span>):
            <span class="kw">if</span> key <span class="kw">in</span> self.environ: safe_env[key] = self.environ[key]
        args = dict(fp=self.body, environ=safe_env, keep_blank_values=True)
        <span class="kw">if</span> py31:
            args[<span class="str">'fp'</span>] = NCTextIOWrapper(args[<span class="str">'fp'</span>],
                                         encoding=<span class="str">'utf8'</span>,
                                         newline=<span class="str">'\n'</span>)
        <span class="kw">elif</span> py3k:
            args[<span class="str">'encoding'</span>] = <span class="str">'utf8'</span>
        data = cgi.FieldStorage(**args)
        self[<span class="str">'_cgi.FieldStorage'</span>] = data  <span class="cmt">#http://bugs.python.org/issue18394</span>
        data = data.list <span class="kw">or</span> []
        <span class="kw">for</span> item <span class="kw">in</span> data:
            <span class="kw">if</span> item.filename:
                post[item.name] = FileUpload(item.file, item.name,
                                             item.filename, item.headers)
            <span class="kw">else</span>:
                post[item.name] = item.value
        <span class="kw">return</span> post

    @property
    <span class="kw">def</span> url(self):
        <span class="str">""" The full request URI including hostname and scheme. If your app
            lives behind a reverse proxy or load balancer and you get confusing
            results, make sure that the ``X-Forwarded-Host`` header is set
            correctly. """</span>
        <span class="kw">return</span> self.urlparts.geturl()

    @DictProperty(<span class="str">'environ'</span>, <span class="str">'bottle.request.urlparts'</span>, read_only=True)
    <span class="kw">def</span> urlparts(self):
        <span class="str">""" The :attr:`url` string as an :class:`urlparse.SplitResult` tuple.
            The tuple contains (scheme, host, path, query_string and fragment),
            but the fragment is always empty because it is not visible to the
            server. """</span>
        env = self.environ
        http = env.get(<span class="str">'HTTP_X_FORWARDED_PROTO'</span>) \
             <span class="kw">or</span> env.get(<span class="str">'wsgi.url_scheme'</span>, <span class="str">'http'</span>)
        host = env.get(<span class="str">'HTTP_X_FORWARDED_HOST'</span>) <span class="kw">or</span> env.get(<span class="str">'HTTP_HOST'</span>)
        <span class="kw">if</span> <span class="kw">not</span> host:
            <span class="cmt"># HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.</span>
            host = env.get(<span class="str">'SERVER_NAME'</span>, <span class="str">'127.0.0.1'</span>)
            port = env.get(<span class="str">'SERVER_PORT'</span>)
            <span class="kw">if</span> port <span class="kw">and</span> port != (<span class="str">'80'</span> <span class="kw">if</span> http == <span class="str">'http'</span> <span class="kw">else</span> <span class="str">'443'</span>):
                host += <span class="str">':'</span> + port
        path = urlquote(self.fullpath)
        <span class="kw">return</span> UrlSplitResult(http, host, path, env.get(<span class="str">'QUERY_STRING'</span>), <span class="str">''</span>)

    @property
    <span class="kw">def</span> fullpath(self):
        <span class="str">""" Request path including :attr:`script_name` (if present). """</span>
        <span class="kw">return</span> urljoin(self.script_name, self.path.lstrip(<span class="str">'/'</span>))

    @property
    <span class="kw">def</span> query_string(self):
        <span class="str">""" The raw :attr:`query` part of the URL (everything in between ``?``
            and ``#``) as a string. """</span>
        <span class="kw">return</span> self.environ.get(<span class="str">'QUERY_STRING'</span>, <span class="str">''</span>)

    @property
    <span class="kw">def</span> script_name(self):
        <span class="str">""" The initial portion of the URL's `path` that was removed by a higher
            level (server or routing middleware) before the application was
            called. This script path is returned with leading and tailing
            slashes. """</span>
        script_name = self.environ.get(<span class="str">'SCRIPT_NAME'</span>, <span class="str">''</span>).strip(<span class="str">'/'</span>)
        <span class="kw">return</span> <span class="str">'/'</span> + script_name + <span class="str">'/'</span> <span class="kw">if</span> script_name <span class="kw">else</span> <span class="str">'/'</span>

    <span class="kw">def</span> path_shift(self, shift=<span class="dig">1</span>):
        <span class="str">""" Shift path segments from :attr:`path` to :attr:`script_name` and
            vice versa.

           :param shift: The number of path segments to shift. May be negative
                         to change the shift direction. (default: 1)
        """</span>
        script, path = path_shift(self.environ.get(<span class="str">'SCRIPT_NAME'</span>, <span class="str">'/'</span>), self.path, shift)
        self[<span class="str">'SCRIPT_NAME'</span>], self[<span class="str">'PATH_INFO'</span>] = script, path

    @property
    <span class="kw">def</span> content_length(self):
        <span class="str">""" The request body length as an integer. The client is responsible to
            set this header. Otherwise, the real length of the body is unknown
            and -1 is returned. In this case, :attr:`body` will be empty. """</span>
        <span class="kw">return</span> int(self.environ.get(<span class="str">'CONTENT_LENGTH'</span>) <span class="kw">or</span> -<span class="dig">1</span>)

    @property
    <span class="kw">def</span> content_type(self):
        <span class="str">""" The Content-Type header as a lowercase-string (default: empty). """</span>
        <span class="kw">return</span> self.environ.get(<span class="str">'CONTENT_TYPE'</span>, <span class="str">''</span>).lower()

    @property
    <span class="kw">def</span> is_xhr(self):
        <span class="str">""" True if the request was triggered by a XMLHttpRequest. This only
            works with JavaScript libraries that support the `X-Requested-With`
            header (most of the popular libraries do). """</span>
        requested_with = self.environ.get(<span class="str">'HTTP_X_REQUESTED_WITH'</span>, <span class="str">''</span>)
        <span class="kw">return</span> requested_with.lower() == <span class="str">'xmlhttprequest'</span>

    @property
    <span class="kw">def</span> is_ajax(self):
        <span class="str">""" Alias for :attr:`is_xhr`. "Ajax" is not the right term. """</span>
        <span class="kw">return</span> self.is_xhr

    @property
    <span class="kw">def</span> auth(self):
        <span class="str">""" HTTP authentication data as a (user, password) tuple. This
            implementation currently supports basic (not digest) authentication
            only. If the authentication happened at a higher level (e.g. in the
            front web-server or a middleware), the password field is None, but
            the user field is looked up from the ``REMOTE_USER`` environ
            variable. On any errors, None is returned. """</span>
        basic = parse_auth(self.environ.get(<span class="str">'HTTP_AUTHORIZATION'</span>, <span class="str">''</span>))
        <span class="kw">if</span> basic: <span class="kw">return</span> basic
        ruser = self.environ.get(<span class="str">'REMOTE_USER'</span>)
        <span class="kw">if</span> ruser: <span class="kw">return</span> (ruser, None)
        <span class="kw">return</span> None

    @property
    <span class="kw">def</span> remote_route(self):
        <span class="str">""" A list of all IPs that were involved in this request, starting with
            the client IP and followed by zero or more proxies. This does only
            work if all proxies support the ```X-Forwarded-For`` header. Note
            that this information can be forged by malicious clients. """</span>
        proxy = self.environ.get(<span class="str">'HTTP_X_FORWARDED_FOR'</span>)
        <span class="kw">if</span> proxy: <span class="kw">return</span> [ip.strip() <span class="kw">for</span> ip <span class="kw">in</span> proxy.split(<span class="str">','</span>)]
        remote = self.environ.get(<span class="str">'REMOTE_ADDR'</span>)
        <span class="kw">return</span> [remote] <span class="kw">if</span> remote <span class="kw">else</span> []

    @property
    <span class="kw">def</span> remote_addr(self):
        <span class="str">""" The client IP as a string. Note that this information can be forged
            by malicious clients. """</span>
        route = self.remote_route
        <span class="kw">return</span> route[<span class="dig">0</span>] <span class="kw">if</span> route <span class="kw">else</span> None

    <span class="kw">def</span> copy(self):
        <span class="str">""" Return a new :class:`Request` with a shallow :attr:`environ` copy. """</span>
        <span class="kw">return</span> Request(self.environ.copy())

    <span class="kw">def</span> get(self, value, default=None):
        <span class="kw">return</span> self.environ.get(value, default)

    <span class="kw">def</span> __getitem__(self, key):
        <span class="kw">return</span> self.environ[key]

    <span class="kw">def</span> __delitem__(self, key):
        self[key] = <span class="str">""</span>
        <span class="kw">del</span> (self.environ[key])

    <span class="kw">def</span> __iter__(self):
        <span class="kw">return</span> iter(self.environ)

    <span class="kw">def</span> __len__(self):
        <span class="kw">return</span> len(self.environ)

    <span class="kw">def</span> keys(self):
        <span class="kw">return</span> self.environ.keys()

    <span class="kw">def</span> __setitem__(self, key, value):
        <span class="str">""" Change an environ value and clear all caches that depend on it. """</span>

        <span class="kw">if</span> self.environ.get(<span class="str">'bottle.request.readonly'</span>):
            <span class="kw">raise</span> KeyError(<span class="str">'The environ dictionary is read-only.'</span>)

        self.environ[key] = value
        todelete = ()

        <span class="kw">if</span> key == <span class="str">'wsgi.input'</span>:
            todelete = (<span class="str">'body'</span>, <span class="str">'forms'</span>, <span class="str">'files'</span>, <span class="str">'params'</span>, <span class="str">'post'</span>, <span class="str">'json'</span>)
        <span class="kw">elif</span> key == <span class="str">'QUERY_STRING'</span>:
            todelete = (<span class="str">'query'</span>, <span class="str">'params'</span>)
        <span class="kw">elif</span> key.startswith(<span class="str">'HTTP_'</span>):
            todelete = (<span class="str">'headers'</span>, <span class="str">'cookies'</span>)

        <span class="kw">for</span> key <span class="kw">in</span> todelete:
            self.environ.pop(<span class="str">'bottle.request.'</span> + key, None)

    <span class="kw">def</span> __repr__(self):
        <span class="kw">return</span> <span class="str">'&lt;%s: %s %s&gt;'</span> % (self.__class__.__name__, self.method, self.url)

    <span class="kw">def</span> __getattr__(self, name):
        <span class="str">""" Search in self.environ for additional user defined attributes. """</span>
        <span class="kw">try</span>:
            var = self.environ[<span class="str">'bottle.request.ext.%s'</span> % name]
            <span class="kw">return</span> var.__get__(self) <span class="kw">if</span> hasattr(var, <span class="str">'__get__'</span>) <span class="kw">else</span> var
        <span class="kw">except</span> KeyError:
            <span class="kw">raise</span> AttributeError(<span class="str">'Attribute %r not defined.'</span> % name)

    <span class="kw">def</span> __setattr__(self, name, value):
        <span class="kw">if</span> name == <span class="str">'environ'</span>: <span class="kw">return</span> object.__setattr__(self, name, value)
        key = <span class="str">'bottle.request.ext.%s'</span> % name
        <span class="kw">if</span> key <span class="kw">in</span> self.environ:
            <span class="kw">raise</span> AttributeError(<span class="str">"Attribute already defined: %s"</span> % name)
        self.environ[key] = value

    <span class="kw">def</span> __delattr__(self, name, value):
        <span class="kw">try</span>:
            <span class="kw">del</span> self.environ[<span class="str">'bottle.request.ext.%s'</span> % name]
        <span class="kw">except</span> KeyError:
            <span class="kw">raise</span> AttributeError(<span class="str">"Attribute not defined: %s"</span> % name)

<span class="kw">def</span> _hkey(s):
    <span class="kw">return</span> s.title().replace(<span class="str">'_'</span>, <span class="str">'-'</span>)


<span class="kw">class</span> HeaderProperty(object):
    <span class="kw">def</span> __init__(self, name, reader=None, writer=str, default=<span class="str">''</span>):
        self.name, self.default = name, default
        self.reader, self.writer = reader, writer
        self.__doc__ = <span class="str">'Current value of the %r header.'</span> % name.title()

    <span class="kw">def</span> __get__(self, obj, _):
        <span class="kw">if</span> obj <span class="kw">is</span> None: <span class="kw">return</span> self
        value = obj.headers.get(self.name, self.default)
        <span class="kw">return</span> self.reader(value) <span class="kw">if</span> self.reader <span class="kw">else</span> value

    <span class="kw">def</span> __set__(self, obj, value):
        obj.headers[self.name] = self.writer(value)

    <span class="kw">def</span> __delete__(self, obj):
        <span class="kw">del</span> obj.headers[self.name]


<span class="kw">class</span> BaseResponse(object):
    <span class="str">""" Storage class for a response body as well as headers and cookies.

        This class does support dict-like case-insensitive item-access to
        headers, but is NOT a dict. Most notably, iterating over a response
        yields parts of the body and not the headers.

        :param body: The response body as one of the supported types.
        :param status: Either an HTTP status code (e.g. 200) or a status line
                       including the reason phrase (e.g. '200 OK').
        :param headers: A dictionary or a list of name-value pairs.

        Additional keyword arguments are added to the list of headers.
        Underscores in the header name are replaced with dashes.
    """</span>

    default_status = <span class="dig">200</span>
    default_content_type = <span class="str">'text/html; charset=UTF-8'</span>

    <span class="cmt"># Header blacklist for specific response codes</span>
    <span class="cmt"># (rfc2616 section 10.2.3 and 10.3.5)</span>
    bad_headers = {
        <span class="dig">204</span>: set((<span class="str">'Content-Type'</span>, <span class="str">'Content-Length'</span>)),
        <span class="dig">304</span>: set((<span class="str">'Allow'</span>, <span class="str">'Content-Encoding'</span>, <span class="str">'Content-Language'</span>,
                  <span class="str">'Content-Length'</span>, <span class="str">'Content-Range'</span>, <span class="str">'Content-Type'</span>,
                  <span class="str">'Content-Md5'</span>, <span class="str">'Last-Modified'</span>))
    }

    <span class="kw">def</span> __init__(self, body=<span class="str">''</span>, status=None, headers=None, **more_headers):
        self._cookies = None
        self._headers = {}
        self.body = body
        self.status = status <span class="kw">or</span> self.default_status
        <span class="kw">if</span> headers:
            <span class="kw">if</span> isinstance(headers, dict):
                headers = headers.items()
            <span class="kw">for</span> name, value <span class="kw">in</span> headers:
                self.add_header(name, value)
        <span class="kw">if</span> more_headers:
            <span class="kw">for</span> name, value <span class="kw">in</span> more_headers.items():
                self.add_header(name, value)

    <span class="kw">def</span> copy(self, cls=None):
        <span class="str">""" Returns a copy of self. """</span>
        cls = cls <span class="kw">or</span> BaseResponse
        <span class="kw">assert</span> issubclass(cls, BaseResponse)
        copy = cls()
        copy.status = self.status
        copy._headers = dict((k, v[:]) <span class="kw">for</span> (k, v) <span class="kw">in</span> self._headers.items())
        <span class="kw">if</span> self._cookies:
            copy._cookies = SimpleCookie()
            copy._cookies.load(self._cookies.output(header=<span class="str">''</span>))
        <span class="kw">return</span> copy

    <span class="kw">def</span> __iter__(self):
        <span class="kw">return</span> iter(self.body)

    <span class="kw">def</span> close(self):
        <span class="kw">if</span> hasattr(self.body, <span class="str">'close'</span>):
            self.body.close()

    @property
    <span class="kw">def</span> status_line(self):
        <span class="str">""" The HTTP status line as a string (e.g. ``404 Not Found``)."""</span>
        <span class="kw">return</span> self._status_line

    @property
    <span class="kw">def</span> status_code(self):
        <span class="str">""" The HTTP status code as an integer (e.g. 404)."""</span>
        <span class="kw">return</span> self._status_code

    <span class="kw">def</span> _set_status(self, status):
        <span class="kw">if</span> isinstance(status, int):
            code, status = status, _HTTP_STATUS_LINES.get(status)
        <span class="kw">elif</span> <span class="str">' '</span> <span class="kw">in</span> status:
            status = status.strip()
            code = int(status.split()[<span class="dig">0</span>])
        <span class="kw">else</span>:
            <span class="kw">raise</span> ValueError(<span class="str">'String status line without a reason phrase.'</span>)
        <span class="kw">if</span> <span class="kw">not</span> <span class="dig">100</span> &lt;= code &lt;= <span class="dig">999</span>:
            <span class="kw">raise</span> ValueError(<span class="str">'Status code out of range.'</span>)
        self._status_code = code
        self._status_line = str(status <span class="kw">or</span> (<span class="str">'%d Unknown'</span> % code))

    <span class="kw">def</span> _get_status(self):
        <span class="kw">return</span> self._status_line

    status = property(
        _get_status, _set_status, None,
        <span class="str">''' A writeable property to change the HTTP response status. It accepts
            either a numeric code (100-999) or a string with a custom reason
            phrase (e.g. "404 Brain not found"). Both :data:`status_line` and
            :data:`status_code` are updated accordingly. The return value is
            always a status string. '''</span>)
    <span class="kw">del</span> _get_status, _set_status

    @property
    <span class="kw">def</span> headers(self):
        <span class="str">""" An instance of :class:`HeaderDict`, a case-insensitive dict-like
            view on the response headers. """</span>
        hdict = HeaderDict()
        hdict.dict = self._headers
        <span class="kw">return</span> hdict

    <span class="kw">def</span> __contains__(self, name):
        <span class="kw">return</span> _hkey(name) <span class="kw">in</span> self._headers

    <span class="kw">def</span> __delitem__(self, name):
        <span class="kw">del</span> self._headers[_hkey(name)]

    <span class="kw">def</span> __getitem__(self, name):
        <span class="kw">return</span> self._headers[_hkey(name)][-<span class="dig">1</span>]

    <span class="kw">def</span> __setitem__(self, name, value):
        self._headers[_hkey(name)] = [value <span class="kw">if</span> isinstance(value, unicode) <span class="kw">else</span>
                                      str(value)]

    <span class="kw">def</span> get_header(self, name, default=None):
        <span class="str">""" Return the value of a previously defined header. If there is no
            header with that name, return a default value. """</span>
        <span class="kw">return</span> self._headers.get(_hkey(name), [default])[-<span class="dig">1</span>]

    <span class="kw">def</span> set_header(self, name, value):
        <span class="str">""" Create a new response header, replacing any previously defined
            headers with the same name. """</span>
        self._headers[_hkey(name)] = [value <span class="kw">if</span> isinstance(value, unicode)
                                            <span class="kw">else</span> str(value)]

    <span class="kw">def</span> add_header(self, name, value):
        <span class="str">""" Add an additional response header, not removing duplicates. """</span>
        self._headers.setdefault(_hkey(name), []).append(
            value <span class="kw">if</span> isinstance(value, unicode) <span class="kw">else</span> str(value))

    <span class="kw">def</span> iter_headers(self):
        <span class="str">""" Yield (header, value) tuples, skipping headers that are not
            allowed with the current response status code. """</span>
        <span class="kw">return</span> self.headerlist

    @property
    <span class="kw">def</span> headerlist(self):
        <span class="str">""" WSGI conform list of (header, value) tuples. """</span>
        out = []
        headers = list(self._headers.items())
        <span class="kw">if</span> <span class="str">'Content-Type'</span> <span class="kw">not</span> <span class="kw">in</span> self._headers:
            headers.append((<span class="str">'Content-Type'</span>, [self.default_content_type]))
        <span class="kw">if</span> self._status_code <span class="kw">in</span> self.bad_headers:
            bad_headers = self.bad_headers[self._status_code]
            headers = [h <span class="kw">for</span> h <span class="kw">in</span> headers <span class="kw">if</span> h[<span class="dig">0</span>] <span class="kw">not</span> <span class="kw">in</span> bad_headers]
        out += [(name, val) <span class="kw">for</span> (name, vals) <span class="kw">in</span> headers <span class="kw">for</span> val <span class="kw">in</span> vals]
        <span class="kw">if</span> self._cookies:
            <span class="kw">for</span> c <span class="kw">in</span> self._cookies.values():
                out.append((<span class="str">'Set-Cookie'</span>, c.OutputString()))
        <span class="kw">if</span> py3k:
            <span class="kw">return</span> [(k, v.encode(<span class="str">'utf8'</span>).decode(<span class="str">'latin1'</span>)) <span class="kw">for</span> (k, v) <span class="kw">in</span> out]
        <span class="kw">else</span>:
            <span class="kw">return</span> [(k, v.encode(<span class="str">'utf8'</span>) <span class="kw">if</span> isinstance(v, unicode) <span class="kw">else</span> v)
                    <span class="kw">for</span> (k, v) <span class="kw">in</span> out]

    content_type = HeaderProperty(<span class="str">'Content-Type'</span>)
    content_length = HeaderProperty(<span class="str">'Content-Length'</span>, reader=int)
    expires = HeaderProperty(
        <span class="str">'Expires'</span>,
        reader=<span class="kw">lambda</span> x: datetime.utcfromtimestamp(parse_date(x)),
        writer=<span class="kw">lambda</span> x: http_date(x))

    @property
    <span class="kw">def</span> charset(self, default=<span class="str">'UTF-8'</span>):
        <span class="str">""" Return the charset specified in the content-type header (default: utf8). """</span>
        <span class="kw">if</span> <span class="str">'charset='</span> <span class="kw">in</span> self.content_type:
            <span class="kw">return</span> self.content_type.split(<span class="str">'charset='</span>)[-<span class="dig">1</span>].split(<span class="str">';'</span>)[<span class="dig">0</span>].strip()
        <span class="kw">return</span> default

    <span class="kw">def</span> set_cookie(self, name, value, secret=None, **options):
        <span class="str">""" Create a new cookie or replace an old one. If the `secret` parameter is
            set, create a `Signed Cookie` (described below).

            :param name: the name of the cookie.
            :param value: the value of the cookie.
            :param secret: a signature key required for signed cookies.

            Additionally, this method accepts all RFC 2109 attributes that are
            supported by :class:`cookie.Morsel`, including:

            :param max_age: maximum age in seconds. (default: None)
            :param expires: a datetime object or UNIX timestamp. (default: None)
            :param domain: the domain that is allowed to read the cookie.
              (default: current domain)
            :param path: limits the cookie to a given path (default: current path)
            :param secure: limit the cookie to HTTPS connections (default: off).
            :param httponly: prevents client-side javascript to read this cookie
              (default: off, requires Python 2.6 or newer).

            If neither `expires` nor `max_age` is set (default), the cookie will
            expire at the end of the browser session (as soon as the browser
            window is closed).

            Signed cookies may store any pickle-able object and are
            cryptographically signed to prevent manipulation. Keep in mind that
            cookies are limited to 4kb in most browsers.

            Warning: Signed cookies are not encrypted (the client can still see
            the content) and not copy-protected (the client can restore an old
            cookie). The main intention is to make pickling and unpickling
            save, not to store secret information at client side.
        """</span>
        <span class="kw">if</span> <span class="kw">not</span> self._cookies:
            self._cookies = SimpleCookie()

        <span class="kw">if</span> secret:
            value = touni(cookie_encode((name, value), secret))
        <span class="kw">elif</span> <span class="kw">not</span> isinstance(value, basestring):
            <span class="kw">raise</span> TypeError(<span class="str">'Secret key missing for non-string Cookie.'</span>)

        <span class="cmt"># Cookie size plus options must not exceed 4kb.</span>
        <span class="kw">if</span> len(name) + len(value) &gt; <span class="dig">3800</span>:
            <span class="kw">raise</span> ValueError(<span class="str">'Content does not fit into a cookie.'</span>)

        self._cookies[name] = value

        <span class="kw">for</span> key, value <span class="kw">in</span> options.items():
            <span class="kw">if</span> key == <span class="str">'max_age'</span>:
                <span class="kw">if</span> isinstance(value, timedelta):
                    value = value.seconds + value.days * <span class="dig">24</span> * <span class="dig">3600</span>
            <span class="kw">if</span> key == <span class="str">'expires'</span>:
                <span class="kw">if</span> isinstance(value, (datedate, datetime)):
                    value = value.timetuple()
                <span class="kw">elif</span> isinstance(value, (int, float)):
                    value = time.gmtime(value)
                value = time.strftime(<span class="str">"%a, %d %b %Y %H:%M:%S GMT"</span>, value)
            <span class="kw">if</span> key <span class="kw">in</span> (<span class="str">'secure'</span>, <span class="str">'httponly'</span>) <span class="kw">and</span> <span class="kw">not</span> value:
                <span class="kw">continue</span>
            self._cookies[name][key.replace(<span class="str">'_'</span>, <span class="str">'-'</span>)] = value

    <span class="kw">def</span> delete_cookie(self, key, **kwargs):
        <span class="str">""" Delete a cookie. Be sure to use the same `domain` and `path`
            settings as used to create the cookie. """</span>
        kwargs[<span class="str">'max_age'</span>] = -<span class="dig">1</span>
        kwargs[<span class="str">'expires'</span>] = <span class="dig">0</span>
        self.set_cookie(key, <span class="str">''</span>, **kwargs)

    <span class="kw">def</span> __repr__(self):
        out = <span class="str">''</span>
        <span class="kw">for</span> name, value <span class="kw">in</span> self.headerlist:
            out += <span class="str">'%s: %s\n'</span> % (name.title(), value.strip())
        <span class="kw">return</span> out


<span class="kw">def</span> _local_property():
    ls = threading.local()

    <span class="kw">def</span> fget(_):
        <span class="kw">try</span>:
            <span class="kw">return</span> ls.var
        <span class="kw">except</span> AttributeError:
            <span class="kw">raise</span> RuntimeError(<span class="str">"Request context not initialized."</span>)

    <span class="kw">def</span> fset(_, value):
        ls.var = value

    <span class="kw">def</span> fdel(_):
        <span class="kw">del</span> ls.var

    <span class="kw">return</span> property(fget, fset, fdel, <span class="str">'Thread-local property'</span>)


<span class="kw">class</span> LocalRequest(BaseRequest):
    <span class="str">""" A thread-local subclass of :class:`BaseRequest` with a different
        set of attributes for each thread. There is usually only one global
        instance of this class (:data:`request`). If accessed during a
        request/response cycle, this instance always refers to the *current*
        request (even on a multithreaded server). """</span>
    bind = BaseRequest.__init__
    environ = _local_property()


<span class="kw">class</span> LocalResponse(BaseResponse):
    <span class="str">""" A thread-local subclass of :class:`BaseResponse` with a different
        set of attributes for each thread. There is usually only one global
        instance of this class (:data:`response`). Its attributes are used
        to build the HTTP response at the end of the request/response cycle.
    """</span>
    bind = BaseResponse.__init__
    _status_line = _local_property()
    _status_code = _local_property()
    _cookies = _local_property()
    _headers = _local_property()
    body = _local_property()


Request = BaseRequest
Response = BaseResponse


<span class="kw">class</span> HTTPResponse(Response, BottleException):
    <span class="kw">def</span> __init__(self, body=<span class="str">''</span>, status=None, headers=None, **more_headers):
        super(HTTPResponse, self).__init__(body, status, headers, **more_headers)

    <span class="kw">def</span> apply(self, other):
        other._status_code = self._status_code
        other._status_line = self._status_line
        other._headers = self._headers
        other._cookies = self._cookies
        other.body = self.body


<span class="kw">class</span> HTTPError(HTTPResponse):
    default_status = <span class="dig">500</span>

    <span class="kw">def</span> __init__(self,
                 status=None,
                 body=None,
                 exception=None,
                 traceback=None, **more_headers):
        self.exception = exception
        self.traceback = traceback
        super(HTTPError, self).__init__(body, status, **more_headers)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Plugins ######################################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> PluginError(BottleException):
    <span class="kw">pass</span>


<span class="kw">class</span> JSONPlugin(object):
    name = <span class="str">'json'</span>
    api = <span class="dig">2</span>

    <span class="kw">def</span> __init__(self, json_dumps=json_dumps):
        self.json_dumps = json_dumps

    <span class="kw">def</span> apply(self, callback, _):
        dumps = self.json_dumps
        <span class="kw">if</span> <span class="kw">not</span> dumps: <span class="kw">return</span> callback

        <span class="kw">def</span> wrapper(*a, **ka):
            <span class="kw">try</span>:
                rv = callback(*a, **ka)
            <span class="kw">except</span> HTTPError:
                rv = _e()

            <span class="kw">if</span> isinstance(rv, dict):
                <span class="cmt">#Attempt to serialize, raises exception on failure</span>
                json_response = dumps(rv)
                <span class="cmt">#Set content type only if serialization successful</span>
                response.content_type = <span class="str">'application/json'</span>
                <span class="kw">return</span> json_response
            <span class="kw">elif</span> isinstance(rv, HTTPResponse) <span class="kw">and</span> isinstance(rv.body, dict):
                rv.body = dumps(rv.body)
                rv.content_type = <span class="str">'application/json'</span>
            <span class="kw">return</span> rv

        <span class="kw">return</span> wrapper


<span class="kw">class</span> TemplatePlugin(object):
    <span class="str">""" This plugin applies the :func:`view` decorator to all routes with a
        `template` config parameter. If the parameter is a tuple, the second
        element must be a dict with additional options (e.g. `template_engine`)
        or default variables for the template. """</span>
    name = <span class="str">'template'</span>
    api = <span class="dig">2</span>

    <span class="kw">def</span> setup(self, app):
        app.tpl = self

    <span class="kw">def</span> apply(self, callback, route):
        conf = route.config.get(<span class="str">'template'</span>)
        <span class="kw">if</span> isinstance(conf, (tuple, list)) <span class="kw">and</span> len(conf) == <span class="dig">2</span>:
            <span class="kw">return</span> view(conf[<span class="dig">0</span>], **conf[<span class="dig">1</span>])(callback)
        <span class="kw">elif</span> isinstance(conf, str):
            <span class="kw">return</span> view(conf)(callback)
        <span class="kw">else</span>:
            <span class="kw">return</span> callback




<span class="cmt">#: Not a plugin, but part of the plugin API. TODO: Find a better place.</span>
<span class="kw">class</span> _ImportRedirect(object):
    <span class="kw">def</span> __init__(self, name, impmask):
        <span class="str">""" Create a virtual package that redirects imports (see PEP 302). """</span>
        self.name = name
        self.impmask = impmask
        self.module = sys.modules.setdefault(name, imp.new_module(name))
        self.module.__dict__.update({
            <span class="str">'__file__'</span>: __file__,
            <span class="str">'__path__'</span>: [],
            <span class="str">'__all__'</span>: [],
            <span class="str">'__loader__'</span>: self
        })
        sys.meta_path.append(self)

    <span class="kw">def</span> find_module(self, fullname, path=None):
        <span class="kw">if</span> <span class="str">'.'</span> <span class="kw">not</span> <span class="kw">in</span> fullname: <span class="kw">return</span>
        packname = fullname.rsplit(<span class="str">'.'</span>, <span class="dig">1</span>)[<span class="dig">0</span>]
        <span class="kw">if</span> packname != self.name: <span class="kw">return</span>
        <span class="kw">return</span> self

    <span class="kw">def</span> load_module(self, fullname):
        <span class="kw">if</span> fullname <span class="kw">in</span> sys.modules: <span class="kw">return</span> sys.modules[fullname]
        modname = fullname.rsplit(<span class="str">'.'</span>, <span class="dig">1</span>)[<span class="dig">1</span>]
        realname = self.impmask % modname
        __import__(realname)
        module = sys.modules[fullname] = sys.modules[realname]
        setattr(self.module, modname, module)
        module.__loader__ = self
        <span class="kw">return</span> module

<span class="cmt">###############################################################################</span>
<span class="cmt"># Common Utilities #############################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> MultiDict(DictMixin):
    <span class="str">""" This dict stores multiple values per key, but behaves exactly like a
        normal dict in that it returns only the newest value for any given key.
        There are special methods available to access the full list of values.
    """</span>

    <span class="kw">def</span> __init__(self, *a, **k):
        self.dict = dict((k, [v]) <span class="kw">for</span> (k, v) <span class="kw">in</span> dict(*a, **k).items())

    <span class="kw">def</span> __len__(self):
        <span class="kw">return</span> len(self.dict)

    <span class="kw">def</span> __iter__(self):
        <span class="kw">return</span> iter(self.dict)

    <span class="kw">def</span> __contains__(self, key):
        <span class="kw">return</span> key <span class="kw">in</span> self.dict

    <span class="kw">def</span> __delitem__(self, key):
        <span class="kw">del</span> self.dict[key]

    <span class="kw">def</span> __getitem__(self, key):
        <span class="kw">return</span> self.dict[key][-<span class="dig">1</span>]

    <span class="kw">def</span> __setitem__(self, key, value):
        self.append(key, value)

    <span class="kw">def</span> keys(self):
        <span class="kw">return</span> self.dict.keys()

    <span class="kw">if</span> py3k:

        <span class="kw">def</span> values(self):
            <span class="kw">return</span> (v[-<span class="dig">1</span>] <span class="kw">for</span> v <span class="kw">in</span> self.dict.values())

        <span class="kw">def</span> items(self):
            <span class="kw">return</span> ((k, v[-<span class="dig">1</span>]) <span class="kw">for</span> k, v <span class="kw">in</span> self.dict.items())

        <span class="kw">def</span> allitems(self):
            <span class="kw">return</span> ((k, v) <span class="kw">for</span> k, vl <span class="kw">in</span> self.dict.items() <span class="kw">for</span> v <span class="kw">in</span> vl)

        iterkeys = keys
        itervalues = values
        iteritems = items
        iterallitems = allitems

    <span class="kw">else</span>:

        <span class="kw">def</span> values(self):
            <span class="kw">return</span> [v[-<span class="dig">1</span>] <span class="kw">for</span> v <span class="kw">in</span> self.dict.values()]

        <span class="kw">def</span> items(self):
            <span class="kw">return</span> [(k, v[-<span class="dig">1</span>]) <span class="kw">for</span> k, v <span class="kw">in</span> self.dict.items()]

        <span class="kw">def</span> iterkeys(self):
            <span class="kw">return</span> self.dict.iterkeys()

        <span class="kw">def</span> itervalues(self):
            <span class="kw">return</span> (v[-<span class="dig">1</span>] <span class="kw">for</span> v <span class="kw">in</span> self.dict.itervalues())

        <span class="kw">def</span> iteritems(self):
            <span class="kw">return</span> ((k, v[-<span class="dig">1</span>]) <span class="kw">for</span> k, v <span class="kw">in</span> self.dict.iteritems())

        <span class="kw">def</span> iterallitems(self):
            <span class="kw">return</span> ((k, v) <span class="kw">for</span> k, vl <span class="kw">in</span> self.dict.iteritems() <span class="kw">for</span> v <span class="kw">in</span> vl)

        <span class="kw">def</span> allitems(self):
            <span class="kw">return</span> [(k, v) <span class="kw">for</span> k, vl <span class="kw">in</span> self.dict.iteritems() <span class="kw">for</span> v <span class="kw">in</span> vl]

    <span class="kw">def</span> get(self, key, default=None, index=-<span class="dig">1</span>, <span class="skw">type</span>=None):
        <span class="str">""" Return the most recent value for a key.

            :param default: The default value to be returned if the key is not
                   present or the type conversion fails.
            :param index: An index for the list of available values.
            :param type: If defined, this callable is used to cast the value
                    into a specific type. Exception are suppressed and result in
                    the default value to be returned.
        """</span>
        <span class="kw">try</span>:
            val = self.dict[key][index]
            <span class="kw">return</span> <span class="skw">type</span>(val) <span class="kw">if</span> <span class="skw">type</span> <span class="kw">else</span> val
        <span class="kw">except</span> Exception:
            <span class="kw">pass</span>
        <span class="kw">return</span> default

    <span class="kw">def</span> append(self, key, value):
        <span class="str">""" Add a new value to the list of values for this key. """</span>
        self.dict.setdefault(key, []).append(value)

    <span class="kw">def</span> replace(self, key, value):
        <span class="str">""" Replace the list of values with a single value. """</span>
        self.dict[key] = [value]

    <span class="kw">def</span> getall(self, key):
        <span class="str">""" Return a (possibly empty) list of values for a key. """</span>
        <span class="kw">return</span> self.dict.get(key) <span class="kw">or</span> []

    <span class="cmt">#: Aliases for WTForms to mimic other multi-dict APIs (Django)</span>
    getone = get
    getlist = getall


<span class="kw">class</span> FormsDict(MultiDict):
    <span class="str">""" This :class:`MultiDict` subclass is used to store request form data.
        Additionally to the normal dict-like item access methods (which return
        unmodified data as native strings), this container also supports
        attribute-like access to its values. Attributes are automatically de-
        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing
        attributes default to an empty string. """</span>

    <span class="cmt">#: Encoding used for attribute values.</span>
    input_encoding = <span class="str">'utf8'</span>
    <span class="cmt">#: If true (default), unicode strings are first encoded with `latin1`</span>
    <span class="cmt">#: and then decoded to match :attr:`input_encoding`.</span>
    recode_unicode = True

    <span class="kw">def</span> _fix(self, s, encoding=None):
        <span class="kw">if</span> isinstance(s, unicode) <span class="kw">and</span> self.recode_unicode:  <span class="cmt"># Python 3 WSGI</span>
            <span class="kw">return</span> s.encode(<span class="str">'latin1'</span>).decode(encoding <span class="kw">or</span> self.input_encoding)
        <span class="kw">elif</span> isinstance(s, bytes):  <span class="cmt"># Python 2 WSGI</span>
            <span class="kw">return</span> s.decode(encoding <span class="kw">or</span> self.input_encoding)
        <span class="kw">else</span>:
            <span class="kw">return</span> s

    <span class="kw">def</span> decode(self, encoding=None):
        <span class="str">""" Returns a copy with all keys and values de- or recoded to match
            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a
            unicode dictionary. """</span>
        copy = FormsDict()
        enc = copy.input_encoding = encoding <span class="kw">or</span> self.input_encoding
        copy.recode_unicode = False
        <span class="kw">for</span> key, value <span class="kw">in</span> self.allitems():
            copy.append(self._fix(key, enc), self._fix(value, enc))
        <span class="kw">return</span> copy

    <span class="kw">def</span> getunicode(self, name, default=None, encoding=None):
        <span class="str">""" Return the value as a unicode string, or the default. """</span>
        <span class="kw">try</span>:
            <span class="kw">return</span> self._fix(self[name], encoding)
        <span class="kw">except</span> (UnicodeError, KeyError):
            <span class="kw">return</span> default

    <span class="kw">def</span> __getattr__(self, name, default=unicode()):
        <span class="cmt"># Without this guard, pickle generates a cryptic TypeError:</span>
        <span class="kw">if</span> name.startswith(<span class="str">'__'</span>) <span class="kw">and</span> name.endswith(<span class="str">'__'</span>):
            <span class="kw">return</span> super(FormsDict, self).__getattr__(name)
        <span class="kw">return</span> self.getunicode(name, default=default)


<span class="kw">class</span> HeaderDict(MultiDict):
    <span class="str">""" A case-insensitive version of :class:`MultiDict` that defaults to
        replace the old value instead of appending it. """</span>

    <span class="kw">def</span> __init__(self, *a, **ka):
        self.dict = {}
        <span class="kw">if</span> a <span class="kw">or</span> ka: self.update(*a, **ka)

    <span class="kw">def</span> __contains__(self, key):
        <span class="kw">return</span> _hkey(key) <span class="kw">in</span> self.dict

    <span class="kw">def</span> __delitem__(self, key):
        <span class="kw">del</span> self.dict[_hkey(key)]

    <span class="kw">def</span> __getitem__(self, key):
        <span class="kw">return</span> self.dict[_hkey(key)][-<span class="dig">1</span>]

    <span class="kw">def</span> __setitem__(self, key, value):
        self.dict[_hkey(key)] = [value <span class="kw">if</span> isinstance(value, unicode) <span class="kw">else</span>
                                 str(value)]

    <span class="kw">def</span> append(self, key, value):
        self.dict.setdefault(_hkey(key), []).append(
            value <span class="kw">if</span> isinstance(value, unicode) <span class="kw">else</span> str(value))

    <span class="kw">def</span> replace(self, key, value):
        self.dict[_hkey(key)] = [value <span class="kw">if</span> isinstance(value, unicode) <span class="kw">else</span>
                                 str(value)]

    <span class="kw">def</span> getall(self, key):
        <span class="kw">return</span> self.dict.get(_hkey(key)) <span class="kw">or</span> []

    <span class="kw">def</span> get(self, key, default=None, index=-<span class="dig">1</span>):
        <span class="kw">return</span> MultiDict.get(self, _hkey(key), default, index)

    <span class="kw">def</span> filter(self, names):
        <span class="kw">for</span> name <span class="kw">in</span> [_hkey(n) <span class="kw">for</span> n <span class="kw">in</span> names]:
            <span class="kw">if</span> name <span class="kw">in</span> self.dict:
                <span class="kw">del</span> self.dict[name]


<span class="kw">class</span> WSGIHeaderDict(DictMixin):
    <span class="str">""" This dict-like class wraps a WSGI environ dict and provides convenient
        access to HTTP_* fields. Keys and values are native strings
        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI
        environment contains non-native string values, these are de- or encoded
        using a lossless 'latin1' character set.

        The API will remain stable even on changes to the relevant PEPs.
        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one
        that uses non-native strings.)
    """</span>
    <span class="cmt">#: List of keys that do not have a ``HTTP_`` prefix.</span>
    cgikeys = (<span class="str">'CONTENT_TYPE'</span>, <span class="str">'CONTENT_LENGTH'</span>)

    <span class="kw">def</span> __init__(self, environ):
        self.environ = environ

    <span class="kw">def</span> _ekey(self, key):
        <span class="str">""" Translate header field name to CGI/WSGI environ key. """</span>
        key = key.replace(<span class="str">'-'</span>, <span class="str">'_'</span>).upper()
        <span class="kw">if</span> key <span class="kw">in</span> self.cgikeys:
            <span class="kw">return</span> key
        <span class="kw">return</span> <span class="str">'HTTP_'</span> + key

    <span class="kw">def</span> raw(self, key, default=None):
        <span class="str">""" Return the header value as is (may be bytes or unicode). """</span>
        <span class="kw">return</span> self.environ.get(self._ekey(key), default)

    <span class="kw">def</span> __getitem__(self, key):
        val = self.environ[self._ekey(key)]
        <span class="kw">if</span> py3k:
            <span class="kw">if</span> isinstance(val, unicode):
                val = val.encode(<span class="str">'latin1'</span>).decode(<span class="str">'utf8'</span>)
            <span class="kw">else</span>:
                val = val.decode(<span class="str">'utf8'</span>)
        <span class="kw">return</span> val

    <span class="kw">def</span> __setitem__(self, key, value):
        <span class="kw">raise</span> TypeError(<span class="str">"%s is read-only."</span> % self.__class__)

    <span class="kw">def</span> __delitem__(self, key):
        <span class="kw">raise</span> TypeError(<span class="str">"%s is read-only."</span> % self.__class__)

    <span class="kw">def</span> __iter__(self):
        <span class="kw">for</span> key <span class="kw">in</span> self.environ:
            <span class="kw">if</span> key[:<span class="dig">5</span>] == <span class="str">'HTTP_'</span>:
                <span class="kw">yield</span> _hkey(key[<span class="dig">5</span>:])
            <span class="kw">elif</span> key <span class="kw">in</span> self.cgikeys:
                <span class="kw">yield</span> _hkey(key)

    <span class="kw">def</span> keys(self):
        <span class="kw">return</span> [x <span class="kw">for</span> x <span class="kw">in</span> self]

    <span class="kw">def</span> __len__(self):
        <span class="kw">return</span> len(self.keys())

    <span class="kw">def</span> __contains__(self, key):
        <span class="kw">return</span> self._ekey(key) <span class="kw">in</span> self.environ


<span class="kw">class</span> ConfigDict(dict):
    <span class="str">""" A dict-like configuration storage with additional support for
        namespaces, validators, meta-data, on_change listeners and more.
    """</span>

    __slots__ = (<span class="str">'_meta'</span>, <span class="str">'_change_listener'</span>, <span class="str">'_fallbacks'</span>)

    <span class="kw">def</span> __init__(self):
        self._meta = {}
        self._change_listener = []
        self._fallbacks = []

    <span class="kw">def</span> load_module(self, path, squash):
        <span class="str">""" Load values from a Python module.
            :param squash: Squash nested dicts into namespaces by using
                           load_dict(), otherwise use update()
            Example: load_config('my.app.settings', True)
            Example: load_config('my.app.settings', False)
        """</span>
        config_obj = __import__(path)
        obj = dict([(key, getattr(config_obj, key))
                <span class="kw">for</span> key <span class="kw">in</span> dir(config_obj) <span class="kw">if</span> key.isupper()])
        <span class="kw">if</span> squash:
            self.load_dict(obj)
        <span class="kw">else</span>:
            self.update(obj)
        <span class="kw">return</span> self

    <span class="kw">def</span> load_config(self, filename):
        <span class="str">""" Load values from an ``*.ini`` style config file.

            If the config file contains sections, their names are used as
            namespaces for the values within. The two special sections
            ``DEFAULT`` and ``bottle`` refer to the root namespace (no prefix).
        """</span>
        conf = ConfigParser()
        conf.read(filename)
        <span class="kw">for</span> section <span class="kw">in</span> conf.sections():
            <span class="kw">for</span> key, value <span class="kw">in</span> conf.items(section):
                <span class="kw">if</span> section <span class="kw">not</span> <span class="kw">in</span> (<span class="str">'DEFAULT'</span>, <span class="str">'bottle'</span>):
                    key = section + <span class="str">'.'</span> + key
                self[key] = value
        <span class="kw">return</span> self

    <span class="kw">def</span> load_dict(self, source, namespace=<span class="str">''</span>):
        <span class="str">""" Load values from a dictionary structure. Nesting can be used to
            represent namespaces.

            &gt;&gt;&gt; c = ConfigDict()
            &gt;&gt;&gt; c.load_dict({'some': {'namespace': {'key': 'value'} } })
            {'some.namespace.key': 'value'}
        """</span>
        <span class="kw">for</span> key, value <span class="kw">in</span> source.items():
            <span class="kw">if</span> isinstance(key, basestring):
                nskey = (namespace + <span class="str">'.'</span> + key).strip(<span class="str">'.'</span>)
                <span class="kw">if</span> isinstance(value, dict):
                    self.load_dict(value, namespace=nskey)
                <span class="kw">else</span>:
                    self[nskey] = value
            <span class="kw">else</span>:
                <span class="kw">raise</span> TypeError(<span class="str">'Key has type %r (not a string)'</span> % <span class="skw">type</span>(key))
        <span class="kw">return</span> self

    <span class="kw">def</span> update(self, *a, **ka):
        <span class="str">""" If the first parameter is a string, all keys are prefixed with this
            namespace. Apart from that it works just as the usual dict.update().
            Example: ``update('some.namespace', key='value')`` """</span>
        prefix = <span class="str">''</span>
        <span class="kw">if</span> a <span class="kw">and</span> isinstance(a[<span class="dig">0</span>], basestring):
            prefix = a[<span class="dig">0</span>].strip(<span class="str">'.'</span>) + <span class="str">'.'</span>
            a = a[<span class="dig">1</span>:]
        <span class="kw">for</span> key, value <span class="kw">in</span> dict(*a, **ka).items():
            self[prefix + key] = value

    <span class="kw">def</span> setdefault(self, key, value):
        <span class="kw">if</span> key <span class="kw">not</span> <span class="kw">in</span> self:
            self[key] = value
        <span class="kw">return</span> self[key]

    <span class="kw">def</span> __setitem__(self, key, value):
        <span class="kw">if</span> <span class="kw">not</span> isinstance(key, basestring):
            <span class="kw">raise</span> TypeError(<span class="str">'Key has type %r (not a string)'</span> % <span class="skw">type</span>(key))

        value = self.meta_get(key, <span class="str">'filter'</span>, <span class="kw">lambda</span> x: x)(value)
        <span class="kw">if</span> key <span class="kw">in</span> self <span class="kw">and</span> self[key] <span class="kw">is</span> value:
            <span class="kw">return</span>
        self._on_change(key, value)
        dict.__setitem__(self, key, value)

    <span class="kw">def</span> __delitem__(self, key):
        self._on_change(key, None)
        dict.__delitem__(self, key)

    <span class="kw">def</span> __missing__(self, key):
        <span class="kw">for</span> fallback <span class="kw">in</span> self._fallbacks:
            <span class="kw">if</span> key <span class="kw">in</span> fallback:
                value = self[key] = fallback[key]
                self.meta_set(key, <span class="str">'fallback'</span>, fallback)
                <span class="kw">return</span> value
        <span class="kw">raise</span> KeyError(key)

    <span class="kw">def</span> _on_change(self, key, value):
        <span class="kw">for</span> cb <span class="kw">in</span> self._change_listener:
            <span class="kw">if</span> cb(self, key, value):
                <span class="kw">return</span> True

    <span class="kw">def</span> _add_change_listener(self, func):
        self._change_listener.append(func)
        <span class="kw">return</span> func

    <span class="kw">def</span> _set_fallback(self, fallback):
        self._fallbacks.append(fallback)

        @fallback._add_change_listener
        <span class="kw">def</span> fallback_update(conf, key, value):
            <span class="kw">if</span> self.meta_get(key, <span class="str">'fallback'</span>) <span class="kw">is</span> conf:
                self.meta_set(key, <span class="str">'fallback'</span>, None)
                dict.__delitem__(self, key)

        @self._add_change_listener
        <span class="kw">def</span> self_update(conf, key, value):
            <span class="kw">if</span> conf.meta_get(key, <span class="str">'fallback'</span>):
                conf.meta_set(key, <span class="str">'fallback'</span>, None)

    <span class="kw">def</span> meta_get(self, key, metafield, default=None):
        <span class="str">""" Return the value of a meta field for a key. """</span>
        <span class="kw">return</span> self._meta.get(key, {}).get(metafield, default)

    <span class="kw">def</span> meta_set(self, key, metafield, value):
        <span class="str">""" Set the meta field for a key to a new value. """</span>
        self._meta.setdefault(key, {})[metafield] = value

    <span class="kw">def</span> meta_list(self, key):
        <span class="str">""" Return an iterable of meta field names defined for a key. """</span>
        <span class="kw">return</span> self._meta.get(key, {}).keys()


<span class="kw">class</span> AppStack(list):
    <span class="str">""" A stack-like list. Calling it returns the head of the stack. """</span>

    <span class="kw">def</span> __call__(self):
        <span class="str">""" Return the current default application. """</span>
        <span class="kw">return</span> self.default

    <span class="kw">def</span> push(self, value=None):
        <span class="str">""" Add a new :class:`Bottle` instance to the stack """</span>
        <span class="kw">if</span> <span class="kw">not</span> isinstance(value, Bottle):
            value = Bottle()
        self.append(value)
        <span class="kw">return</span> value
    new_app = push
    @property
    <span class="kw">def</span> default(self):
        <span class="kw">try</span>:
            <span class="kw">return</span> self[-<span class="dig">1</span>]
        <span class="kw">except</span> IndexError:
            <span class="kw">return</span> self.push()


<span class="kw">class</span> WSGIFileWrapper(object):
    <span class="kw">def</span> __init__(self, fp, buffer_size=<span class="dig">1024</span> * <span class="dig">64</span>):
        self.fp, self.buffer_size = fp, buffer_size
        <span class="kw">for</span> attr <span class="kw">in</span> (<span class="str">'fileno'</span>, <span class="str">'close'</span>, <span class="str">'read'</span>, <span class="str">'readlines'</span>, <span class="str">'tell'</span>, <span class="str">'seek'</span>):
            <span class="kw">if</span> hasattr(fp, attr): setattr(self, attr, getattr(fp, attr))

    <span class="kw">def</span> __iter__(self):
        buff, read = self.buffer_size, self.read
        <span class="kw">while</span> True:
            part = read(buff)
            <span class="kw">if</span> <span class="kw">not</span> part: <span class="kw">return</span>
            <span class="kw">yield</span> part


<span class="kw">class</span> _closeiter(object):
    <span class="str">""" This only exists to be able to attach a .close method to iterators that
        do not support attribute assignment (most of itertools). """</span>

    <span class="kw">def</span> __init__(self, iterator, close=None):
        self.iterator = iterator
        self.close_callbacks = makelist(close)

    <span class="kw">def</span> __iter__(self):
        <span class="kw">return</span> iter(self.iterator)

    <span class="kw">def</span> close(self):
        <span class="kw">for</span> func <span class="kw">in</span> self.close_callbacks:
            func()


<span class="kw">class</span> ResourceManager(object):
    <span class="str">""" This class manages a list of search paths and helps to find and open
        application-bound resources (files).

        :param base: default value for :meth:`add_path` calls.
        :param opener: callable used to open resources.
        :param cachemode: controls which lookups are cached. One of 'all',
                         'found' or 'none'.
    """</span>

    <span class="kw">def</span> __init__(self, base=<span class="str">'./'</span>, opener=open, cachemode=<span class="str">'all'</span>):
        self.opener = opener
        self.base = base
        self.cachemode = cachemode

        <span class="cmt">#: A list of search paths. See :meth:`add_path` for details.</span>
        self.path = []
        <span class="cmt">#: A cache for resolved paths. ``res.cache.clear()`` clears the cache.</span>
        self.cache = {}

    <span class="kw">def</span> add_path(self, path, base=None, index=None, create=False):
        <span class="str">""" Add a new path to the list of search paths. Return False if the
            path does not exist.

            :param path: The new search path. Relative paths are turned into
                an absolute and normalized form. If the path looks like a file
                (not ending in `/`), the filename is stripped off.
            :param base: Path used to absolutize relative search paths.
                Defaults to :attr:`base` which defaults to ``os.getcwd()``.
            :param index: Position within the list of search paths. Defaults
                to last index (appends to the list).

            The `base` parameter makes it easy to reference files installed
            along with a python module or package::

                res.add_path('./resources/', __file__)
        """</span>
        base = os.path.abspath(os.path.dirname(base <span class="kw">or</span> self.base))
        path = os.path.abspath(os.path.join(base, os.path.dirname(path)))
        path += os.sep
        <span class="kw">if</span> path <span class="kw">in</span> self.path:
            self.path.remove(path)
        <span class="kw">if</span> create <span class="kw">and</span> <span class="kw">not</span> os.path.isdir(path):
            os.makedirs(path)
        <span class="kw">if</span> index <span class="kw">is</span> None:
            self.path.append(path)
        <span class="kw">else</span>:
            self.path.insert(index, path)
        self.cache.clear()
        <span class="kw">return</span> os.path.exists(path)

    <span class="kw">def</span> __iter__(self):
        <span class="str">""" Iterate over all existing files in all registered paths. """</span>
        search = self.path[:]
        <span class="kw">while</span> search:
            path = search.pop()
            <span class="kw">if</span> <span class="kw">not</span> os.path.isdir(path): <span class="kw">continue</span>
            <span class="kw">for</span> name <span class="kw">in</span> os.listdir(path):
                full = os.path.join(path, name)
                <span class="kw">if</span> os.path.isdir(full): search.append(full)
                <span class="kw">else</span>: <span class="kw">yield</span> full

    <span class="kw">def</span> lookup(self, name):
        <span class="str">""" Search for a resource and return an absolute file path, or `None`.

            The :attr:`path` list is searched in order. The first match is
            returend. Symlinks are followed. The result is cached to speed up
            future lookups. """</span>
        <span class="kw">if</span> name <span class="kw">not</span> <span class="kw">in</span> self.cache <span class="kw">or</span> DEBUG:
            <span class="kw">for</span> path <span class="kw">in</span> self.path:
                fpath = os.path.join(path, name)
                <span class="kw">if</span> os.path.isfile(fpath):
                    <span class="kw">if</span> self.cachemode <span class="kw">in</span> (<span class="str">'all'</span>, <span class="str">'found'</span>):
                        self.cache[name] = fpath
                    <span class="kw">return</span> fpath
            <span class="kw">if</span> self.cachemode == <span class="str">'all'</span>:
                self.cache[name] = None
        <span class="kw">return</span> self.cache[name]

    <span class="kw">def</span> open(self, name, mode=<span class="str">'r'</span>, *args, **kwargs):
        <span class="str">""" Find a resource and return a file object, or raise IOError. """</span>
        fname = self.lookup(name)
        <span class="kw">if</span> <span class="kw">not</span> fname: <span class="kw">raise</span> IOError(<span class="str">"Resource %r not found."</span> % name)
        <span class="kw">return</span> self.opener(fname, mode=mode, *args, **kwargs)


<span class="kw">class</span> FileUpload(object):
    <span class="kw">def</span> __init__(self, fileobj, name, filename, headers=None):
        <span class="str">""" Wrapper for file uploads. """</span>
        <span class="cmt">#: Open file(-like) object (BytesIO buffer or temporary file)</span>
        self.file = fileobj
        <span class="cmt">#: Name of the upload form field</span>
        self.name = name
        <span class="cmt">#: Raw filename as sent by the client (may contain unsafe characters)</span>
        self.raw_filename = filename
        <span class="cmt">#: A :class:`HeaderDict` with additional headers (e.g. content-type)</span>
        self.headers = HeaderDict(headers) <span class="kw">if</span> headers <span class="kw">else</span> HeaderDict()

    content_type = HeaderProperty(<span class="str">'Content-Type'</span>)
    content_length = HeaderProperty(<span class="str">'Content-Length'</span>, reader=int, default=-<span class="dig">1</span>)

    @cached_property
    <span class="kw">def</span> filename(self):
        <span class="str">""" Name of the file on the client file system, but normalized to ensure
            file system compatibility. An empty filename is returned as 'empty'.

            Only ASCII letters, digits, dashes, underscores and dots are
            allowed in the final filename. Accents are removed, if possible.
            Whitespace is replaced by a single dash. Leading or tailing dots
            or dashes are removed. The filename is limited to 255 characters.
        """</span>
        fname = self.raw_filename
        <span class="kw">if</span> <span class="kw">not</span> isinstance(fname, unicode):
            fname = fname.decode(<span class="str">'utf8'</span>, <span class="str">'ignore'</span>)
        fname = normalize(<span class="str">'NFKD'</span>, fname)
        fname = fname.encode(<span class="str">'ASCII'</span>, <span class="str">'ignore'</span>).decode(<span class="str">'ASCII'</span>)
        fname = os.path.basename(fname.replace(<span class="str">'\\'</span>, os.path.sep))
        fname = re.sub(<span class="str">r'[^a-zA-Z0-9-_.\s]'</span>, <span class="str">''</span>, fname).strip()
        fname = re.sub(<span class="str">r'[-\s]+'</span>, <span class="str">'-'</span>, fname).strip(<span class="str">'.-'</span>)
        <span class="kw">return</span> fname[:<span class="dig">255</span>] <span class="kw">or</span> <span class="str">'empty'</span>

    <span class="kw">def</span> _copy_file(self, fp, chunk_size=<span class="dig">2</span> ** <span class="dig">16</span>):
        read, write, offset = self.file.read, fp.write, self.file.tell()
        <span class="kw">while</span> <span class="dig">1</span>:
            buf = read(chunk_size)
            <span class="kw">if</span> <span class="kw">not</span> buf: <span class="kw">break</span>
            write(buf)
        self.file.seek(offset)

    <span class="kw">def</span> save(self, destination, overwrite=False, chunk_size=<span class="dig">2</span> ** <span class="dig">16</span>):
        <span class="str">""" Save file to disk or copy its content to an open file(-like) object.
            If *destination* is a directory, :attr:`filename` is added to the
            path. Existing files are not overwritten by default (IOError).

            :param destination: File path, directory or file(-like) object.
            :param overwrite: If True, replace existing files. (default: False)
            :param chunk_size: Bytes to read at a time. (default: 64kb)
        """</span>
        <span class="kw">if</span> isinstance(destination, basestring):  <span class="cmt"># Except file-likes here</span>
            <span class="kw">if</span> os.path.isdir(destination):
                destination = os.path.join(destination, self.filename)
            <span class="kw">if</span> <span class="kw">not</span> overwrite <span class="kw">and</span> os.path.exists(destination):
                <span class="kw">raise</span> IOError(<span class="str">'File exists.'</span>)
            <span class="kw">with</span> open(destination, <span class="str">'wb'</span>) <span class="kw">as</span> fp:
                self._copy_file(fp, chunk_size)
        <span class="kw">else</span>:
            self._copy_file(destination, chunk_size)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Application Helper ###########################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">def</span> abort(code=<span class="dig">500</span>, text=<span class="str">'Unknown Error.'</span>):
    <span class="str">""" Aborts execution and causes a HTTP error. """</span>
    <span class="kw">raise</span> HTTPError(code, text)


<span class="kw">def</span> redirect(url, code=None):
    <span class="str">""" Aborts execution and causes a 303 or 302 redirect, depending on
        the HTTP protocol version. """</span>
    <span class="kw">if</span> <span class="kw">not</span> code:
        code = <span class="dig">303</span> <span class="kw">if</span> request.get(<span class="str">'SERVER_PROTOCOL'</span>) == <span class="str">"HTTP/1.1"</span> <span class="kw">else</span> <span class="dig">302</span>
    res = response.copy(cls=HTTPResponse)
    res.status = code
    res.body = <span class="str">""</span>
    res.set_header(<span class="str">'Location'</span>, urljoin(request.url, url))
    <span class="kw">raise</span> res


<span class="kw">def</span> _file_iter_range(fp, offset, bytes, maxread=<span class="dig">1024</span> * <span class="dig">1024</span>):
    <span class="str">""" Yield chunks from a range in a file. No chunk is bigger than maxread."""</span>
    fp.seek(offset)
    <span class="kw">while</span> bytes &gt; <span class="dig">0</span>:
        part = fp.read(min(bytes, maxread))
        <span class="kw">if</span> <span class="kw">not</span> part: <span class="kw">break</span>
        bytes -= len(part)
        <span class="kw">yield</span> part


<span class="kw">def</span> static_file(filename, root,
                mimetype=<span class="str">'auto'</span>,
                download=False,
                charset=<span class="str">'UTF-8'</span>):
    <span class="str">""" Open a file in a safe way and return :exc:`HTTPResponse` with status
        code 200, 305, 403 or 404. The ``Content-Type``, ``Content-Encoding``,
        ``Content-Length`` and ``Last-Modified`` headers are set if possible.
        Special support for ``If-Modified-Since``, ``Range`` and ``HEAD``
        requests.

        :param filename: Name or path of the file to send.
        :param root: Root path for file lookups. Should be an absolute directory
            path.
        :param mimetype: Defines the content-type header (default: guess from
            file extension)
        :param download: If True, ask the browser to open a `Save as...` dialog
            instead of opening the file with the associated program. You can
            specify a custom filename as a string. If not specified, the
            original filename is used (default: False).
        :param charset: The charset to use for files with a ``text/*``
            mime-type. (default: UTF-8)
    """</span>

    root = os.path.abspath(root) + os.sep
    filename = os.path.abspath(os.path.join(root, filename.strip(<span class="str">'/\\'</span>)))
    headers = dict()

    <span class="kw">if</span> <span class="kw">not</span> filename.startswith(root):
        <span class="kw">return</span> HTTPError(<span class="dig">403</span>, <span class="str">"Access denied."</span>)
    <span class="kw">if</span> <span class="kw">not</span> os.path.exists(filename) <span class="kw">or</span> <span class="kw">not</span> os.path.isfile(filename):
        <span class="kw">return</span> HTTPError(<span class="dig">404</span>, <span class="str">"File does not exist."</span>)
    <span class="kw">if</span> <span class="kw">not</span> os.access(filename, os.R_OK):
        <span class="kw">return</span> HTTPError(<span class="dig">403</span>, <span class="str">"You do not have permission to access this file."</span>)

    <span class="kw">if</span> mimetype == <span class="str">'auto'</span>:
        <span class="kw">if</span> download <span class="kw">and</span> download != True:
            mimetype, encoding = mimetypes.guess_type(download)
        <span class="kw">else</span>:
            mimetype, encoding = mimetypes.guess_type(filename)
        <span class="kw">if</span> encoding: headers[<span class="str">'Content-Encoding'</span>] = encoding

    <span class="kw">if</span> mimetype:
        <span class="kw">if</span> (mimetype[:<span class="dig">5</span>] == <span class="str">'text/'</span> <span class="kw">or</span> mimetype == <span class="str">'application/javascript'</span>) <span class="kw">and</span> charset <span class="kw">and</span> <span class="str">'charset'</span> <span class="kw">not</span> <span class="kw">in</span> mimetype:
            mimetype += <span class="str">'; charset=%s'</span> % charset
        headers[<span class="str">'Content-Type'</span>] = mimetype

    <span class="kw">if</span> download:
        download = os.path.basename(filename <span class="kw">if</span> download == True <span class="kw">else</span> download)
        headers[<span class="str">'Content-Disposition'</span>] = <span class="str">'attachment; filename="%s"'</span> % download

    stats = os.stat(filename)
    headers[<span class="str">'Content-Length'</span>] = clen = stats.st_size
    lm = time.strftime(<span class="str">"%a, %d %b %Y %H:%M:%S GMT"</span>, time.gmtime(stats.st_mtime))
    headers[<span class="str">'Last-Modified'</span>] = lm

    ims = request.environ.get(<span class="str">'HTTP_IF_MODIFIED_SINCE'</span>)
    <span class="kw">if</span> ims:
        ims = parse_date(ims.split(<span class="str">";"</span>)[<span class="dig">0</span>].strip())
    <span class="kw">if</span> ims <span class="kw">is</span> <span class="kw">not</span> None <span class="kw">and</span> ims &gt;= int(stats.st_mtime):
        headers[<span class="str">'Date'</span>] = time.strftime(<span class="str">"%a, %d %b %Y %H:%M:%S GMT"</span>,
                                        time.gmtime())
        <span class="kw">return</span> HTTPResponse(status=<span class="dig">304</span>, **headers)

    body = <span class="str">''</span> <span class="kw">if</span> request.method == <span class="str">'HEAD'</span> <span class="kw">else</span> open(filename, <span class="str">'rb'</span>)

    headers[<span class="str">"Accept-Ranges"</span>] = <span class="str">"bytes"</span>
    ranges = request.environ.get(<span class="str">'HTTP_RANGE'</span>)
    <span class="kw">if</span> <span class="str">'HTTP_RANGE'</span> <span class="kw">in</span> request.environ:
        ranges = list(parse_range_header(request.environ[<span class="str">'HTTP_RANGE'</span>], clen))
        <span class="kw">if</span> <span class="kw">not</span> ranges:
            <span class="kw">return</span> HTTPError(<span class="dig">416</span>, <span class="str">"Requested Range Not Satisfiable"</span>)
        offset, end = ranges[<span class="dig">0</span>]
        headers[<span class="str">"Content-Range"</span>] = <span class="str">"bytes %d-%d/%d"</span> % (offset, end - <span class="dig">1</span>, clen)
        headers[<span class="str">"Content-Length"</span>] = str(end - offset)
        <span class="kw">if</span> body: body = _file_iter_range(body, offset, end - offset)
        <span class="kw">return</span> HTTPResponse(body, status=<span class="dig">206</span>, **headers)
    <span class="kw">return</span> HTTPResponse(body, **headers)

<span class="cmt">###############################################################################</span>
<span class="cmt"># HTTP Utilities and MISC (TODO) ###############################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">def</span> debug(mode=True):
    <span class="str">""" Change the debug level.
    There is only one debug level supported at the moment."""</span>
    <span class="kw">global</span> DEBUG
    <span class="kw">if</span> mode: warnings.simplefilter(<span class="str">'default'</span>)
    DEBUG = bool(mode)


<span class="kw">def</span> http_date(value):
    <span class="kw">if</span> isinstance(value, (datedate, datetime)):
        value = value.utctimetuple()
    <span class="kw">elif</span> isinstance(value, (int, float)):
        value = time.gmtime(value)
    <span class="kw">if</span> <span class="kw">not</span> isinstance(value, basestring):
        value = time.strftime(<span class="str">"%a, %d %b %Y %H:%M:%S GMT"</span>, value)
    <span class="kw">return</span> value


<span class="kw">def</span> parse_date(ims):
    <span class="str">""" Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. """</span>
    <span class="kw">try</span>:
        ts = email.utils.parsedate_tz(ims)
        <span class="kw">return</span> time.mktime(ts[:<span class="dig">8</span>] + (<span class="dig">0</span>, )) - (ts[<span class="dig">9</span>] <span class="kw">or</span> <span class="dig">0</span>) - time.timezone
    <span class="kw">except</span> (TypeError, ValueError, IndexError, OverflowError):
        <span class="kw">return</span> None


<span class="kw">def</span> parse_auth(header):
    <span class="str">""" Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None"""</span>
    <span class="kw">try</span>:
        method, data = header.split(None, <span class="dig">1</span>)
        <span class="kw">if</span> method.lower() == <span class="str">'basic'</span>:
            user, pwd = touni(base64.b64decode(tob(data))).split(<span class="str">':'</span>, <span class="dig">1</span>)
            <span class="kw">return</span> user, pwd
    <span class="kw">except</span> (KeyError, ValueError):
        <span class="kw">return</span> None


<span class="kw">def</span> parse_range_header(header, maxlen=<span class="dig">0</span>):
    <span class="str">""" Yield (start, end) ranges parsed from a HTTP Range header. Skip
        unsatisfiable ranges. The end index is non-inclusive."""</span>
    <span class="kw">if</span> <span class="kw">not</span> header <span class="kw">or</span> header[:<span class="dig">6</span>] != <span class="str">'bytes='</span>: <span class="kw">return</span>
    ranges = [r.split(<span class="str">'-'</span>, <span class="dig">1</span>) <span class="kw">for</span> r <span class="kw">in</span> header[<span class="dig">6</span>:].split(<span class="str">','</span>) <span class="kw">if</span> <span class="str">'-'</span> <span class="kw">in</span> r]
    <span class="kw">for</span> start, end <span class="kw">in</span> ranges:
        <span class="kw">try</span>:
            <span class="kw">if</span> <span class="kw">not</span> start:  <span class="cmt"># bytes=-100    -&gt; last 100 bytes</span>
                start, end = max(<span class="dig">0</span>, maxlen - int(end)), maxlen
            <span class="kw">elif</span> <span class="kw">not</span> end:  <span class="cmt"># bytes=100-    -&gt; all but the first 99 bytes</span>
                start, end = int(start), maxlen
            <span class="kw">else</span>:  <span class="cmt"># bytes=100-200 -&gt; bytes 100-200 (inclusive)</span>
                start, end = int(start), min(int(end) + <span class="dig">1</span>, maxlen)
            <span class="kw">if</span> <span class="dig">0</span> &lt;= start &lt; end &lt;= maxlen:
                <span class="kw">yield</span> start, end
        <span class="kw">except</span> ValueError:
            <span class="kw">pass</span>


<span class="cmt">#: Header tokenizer used by _parse_http_header()</span>
_hsplit = re.compile(<span class="str">'(?:(?:"((?:[^"\\\\]+|\\\\.)*)")|([^;,=]+))([;,=]?)'</span>).findall

<span class="kw">def</span> _parse_http_header(h):
    <span class="str">""" Parses a typical multi-valued and parametrised HTTP header (e.g. Accept headers) and returns a list of values
        and parameters. For non-standard or broken input, this implementation may return partial results.
    :param h: A header string (e.g. ``text/html,text/plain;q=0.9,*/*;q=0.8``)
    :return: List of (value, params) tuples. The second element is a (possibly empty) dict.
    """</span>
    values = []
    <span class="kw">if</span> <span class="str">'"'</span> <span class="kw">not</span> <span class="kw">in</span> h:  <span class="cmt"># INFO: Fast path without regexp (~2x faster)</span>
        <span class="kw">for</span> value <span class="kw">in</span> h.split(<span class="str">','</span>):
            parts = value.split(<span class="str">';'</span>)
            values.append((parts[<span class="dig">0</span>].strip(), {}))
            <span class="kw">for</span> attr <span class="kw">in</span> parts[<span class="dig">1</span>:]:
                name, value = attr.split(<span class="str">'='</span>, <span class="dig">1</span>)
                values[-<span class="dig">1</span>][<span class="dig">1</span>][name.strip()] = value.strip()
    <span class="kw">else</span>:
        lop, key, attrs = <span class="str">','</span>, None, {}
        <span class="kw">for</span> quoted, plain, tok <span class="kw">in</span> _hsplit(h):
            value = plain.strip() <span class="kw">if</span> plain <span class="kw">else</span> quoted.replace(<span class="str">'\\"'</span>, <span class="str">'"'</span>)
            <span class="kw">if</span> lop == <span class="str">','</span>:
                attrs = {}
                values.append((value, attrs))
            <span class="kw">elif</span> lop == <span class="str">';'</span>:
                <span class="kw">if</span> tok == <span class="str">'='</span>:
                    key = value
                <span class="kw">else</span>:
                    attrs[value] = <span class="str">''</span>
            <span class="kw">elif</span> lop == <span class="str">'='</span> <span class="kw">and</span> key:
                attrs[key] = value
                key = None
            lop = tok
    <span class="kw">return</span> values


<span class="kw">def</span> _parse_qsl(qs):
    r = []
    <span class="kw">for</span> pair <span class="kw">in</span> qs.replace(<span class="str">';'</span>, <span class="str">'&amp;'</span>).split(<span class="str">'&amp;'</span>):
        <span class="kw">if</span> <span class="kw">not</span> pair: <span class="kw">continue</span>
        nv = pair.split(<span class="str">'='</span>, <span class="dig">1</span>)
        <span class="kw">if</span> len(nv) != <span class="dig">2</span>: nv.append(<span class="str">''</span>)
        key = urlunquote(nv[<span class="dig">0</span>].replace(<span class="str">'+'</span>, <span class="str">' '</span>))
        value = urlunquote(nv[<span class="dig">1</span>].replace(<span class="str">'+'</span>, <span class="str">' '</span>))
        r.append((key, value))
    <span class="kw">return</span> r


<span class="kw">def</span> _lscmp(a, b):
    <span class="str">""" Compares two strings in a cryptographically safe way:
        Runtime is not affected by length of common prefix. """</span>
    <span class="kw">return</span> <span class="kw">not</span> sum(<span class="dig">0</span> <span class="kw">if</span> x == y <span class="kw">else</span> <span class="dig">1</span>
                   <span class="kw">for</span> x, y <span class="kw">in</span> zip(a, b)) <span class="kw">and</span> len(a) == len(b)


<span class="kw">def</span> cookie_encode(data, key, digestmod=None):
    <span class="str">""" Encode and sign a pickle-able object. Return a (byte) string """</span>
    digestmod = digestmod <span class="kw">or</span> hashlib.sha256
    msg = base64.b64encode(pickle.dumps(data, -<span class="dig">1</span>))
    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest())
    <span class="kw">return</span> tob(<span class="str">'!'</span>) + sig + tob(<span class="str">'?'</span>) + msg


<span class="kw">def</span> cookie_decode(data, key, digestmod=None):
    <span class="str">""" Verify and decode an encoded string. Return an object or None."""</span>
    data = tob(data)
    <span class="kw">if</span> cookie_is_encoded(data):
        sig, msg = data.split(tob(<span class="str">'?'</span>), <span class="dig">1</span>)
        digestmod = digestmod <span class="kw">or</span> hashlib.sha256
        hashed = hmac.new(tob(key), msg, digestmod=digestmod).digest()
        <span class="kw">if</span> _lscmp(sig[<span class="dig">1</span>:], base64.b64encode(hashed)):
            <span class="kw">return</span> pickle.loads(base64.b64decode(msg))
    <span class="kw">return</span> None


<span class="kw">def</span> cookie_is_encoded(data):
    <span class="str">""" Return True if the argument looks like a encoded cookie."""</span>
    <span class="kw">return</span> bool(data.startswith(tob(<span class="str">'!'</span>)) <span class="kw">and</span> tob(<span class="str">'?'</span>) <span class="kw">in</span> data)


<span class="kw">def</span> html_escape(string):
    <span class="str">""" Escape HTML special characters ``&amp;&lt;&gt;`` and quotes ``'"``. """</span>
    <span class="kw">return</span> string.replace(<span class="str">'&amp;'</span>, <span class="str">'&amp;amp;'</span>).replace(<span class="str">'&lt;'</span>, <span class="str">'&amp;lt;'</span>).replace(<span class="str">'&gt;'</span>, <span class="str">'&amp;gt;'</span>)\
                 .replace(<span class="str">'"'</span>, <span class="str">'&amp;quot;'</span>).replace(<span class="str">"'"</span>, <span class="str">'&amp;#039;'</span>)


<span class="kw">def</span> html_quote(string):
    <span class="str">""" Escape and quote a string to be used as an HTTP attribute."""</span>
    <span class="kw">return</span> <span class="str">'"%s"'</span> % html_escape(string).replace(<span class="str">'\n'</span>, <span class="str">'&amp;#10;'</span>)\
                    .replace(<span class="str">'\r'</span>, <span class="str">'&amp;#13;'</span>).replace(<span class="str">'\t'</span>, <span class="str">'&amp;#9;'</span>)


<span class="kw">def</span> yieldroutes(func):
    <span class="str">""" Return a generator for routes that match the signature (name, args)
    of the func parameter. This may yield more than one route if the function
    takes optional keyword arguments. The output is best described by example::

        a()         -&gt; '/a'
        b(x, y)     -&gt; '/b/&lt;x&gt;/&lt;y&gt;'
        c(x, y=5)   -&gt; '/c/&lt;x&gt;' and '/c/&lt;x&gt;/&lt;y&gt;'
        d(x=5, y=6) -&gt; '/d' and '/d/&lt;x&gt;' and '/d/&lt;x&gt;/&lt;y&gt;'
    """</span>
    path = <span class="str">'/'</span> + func.__name__.replace(<span class="str">'__'</span>, <span class="str">'/'</span>).lstrip(<span class="str">'/'</span>)
    spec = getargspec(func)
    argc = len(spec[<span class="dig">0</span>]) - len(spec[<span class="dig">3</span>] <span class="kw">or</span> [])
    path += (<span class="str">'/&lt;%s&gt;'</span> * argc) % tuple(spec[<span class="dig">0</span>][:argc])
    <span class="kw">yield</span> path
    <span class="kw">for</span> arg <span class="kw">in</span> spec[<span class="dig">0</span>][argc:]:
        path += <span class="str">'/&lt;%s&gt;'</span> % arg
        <span class="kw">yield</span> path


<span class="kw">def</span> path_shift(script_name, path_info, shift=<span class="dig">1</span>):
    <span class="str">""" Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.

        :return: The modified paths.
        :param script_name: The SCRIPT_NAME path.
        :param script_name: The PATH_INFO path.
        :param shift: The number of path fragments to shift. May be negative to
          change the shift direction. (default: 1)
    """</span>
    <span class="kw">if</span> shift == <span class="dig">0</span>: <span class="kw">return</span> script_name, path_info
    pathlist = path_info.strip(<span class="str">'/'</span>).split(<span class="str">'/'</span>)
    scriptlist = script_name.strip(<span class="str">'/'</span>).split(<span class="str">'/'</span>)
    <span class="kw">if</span> pathlist <span class="kw">and</span> pathlist[<span class="dig">0</span>] == <span class="str">''</span>: pathlist = []
    <span class="kw">if</span> scriptlist <span class="kw">and</span> scriptlist[<span class="dig">0</span>] == <span class="str">''</span>: scriptlist = []
    <span class="kw">if</span> <span class="dig">0</span> &lt; shift &lt;= len(pathlist):
        moved = pathlist[:shift]
        scriptlist = scriptlist + moved
        pathlist = pathlist[shift:]
    <span class="kw">elif</span> <span class="dig">0</span> &gt; shift &gt;= -len(scriptlist):
        moved = scriptlist[shift:]
        pathlist = moved + pathlist
        scriptlist = scriptlist[:shift]
    <span class="kw">else</span>:
        empty = <span class="str">'SCRIPT_NAME'</span> <span class="kw">if</span> shift &lt; <span class="dig">0</span> <span class="kw">else</span> <span class="str">'PATH_INFO'</span>
        <span class="kw">raise</span> AssertionError(<span class="str">"Cannot shift. Nothing left from %s"</span> % empty)
    new_script_name = <span class="str">'/'</span> + <span class="str">'/'</span>.join(scriptlist)
    new_path_info = <span class="str">'/'</span> + <span class="str">'/'</span>.join(pathlist)
    <span class="kw">if</span> path_info.endswith(<span class="str">'/'</span>) <span class="kw">and</span> pathlist: new_path_info += <span class="str">'/'</span>
    <span class="kw">return</span> new_script_name, new_path_info


<span class="kw">def</span> auth_basic(check, realm=<span class="str">"private"</span>, text=<span class="str">"Access denied"</span>):
    <span class="str">""" Callback decorator to require HTTP auth (basic).
        TODO: Add route(check_auth=...) parameter. """</span>

    <span class="kw">def</span> decorator(func):

        @functools.wraps(func)
        <span class="kw">def</span> wrapper(*a, **ka):
            user, password = request.auth <span class="kw">or</span> (None, None)
            <span class="kw">if</span> user <span class="kw">is</span> None <span class="kw">or</span> <span class="kw">not</span> check(user, password):
                err = HTTPError(<span class="dig">401</span>, text)
                err.add_header(<span class="str">'WWW-Authenticate'</span>, <span class="str">'Basic realm="%s"'</span> % realm)
                <span class="kw">return</span> err
            <span class="kw">return</span> func(*a, **ka)

        <span class="kw">return</span> wrapper

    <span class="kw">return</span> decorator

<span class="cmt"># Shortcuts for common Bottle methods.</span>
<span class="cmt"># They all refer to the current default application.</span>


<span class="kw">def</span> make_default_app_wrapper(name):
    <span class="str">""" Return a callable that relays calls to the current default app. """</span>

    @functools.wraps(getattr(Bottle, name))
    <span class="kw">def</span> wrapper(*a, **ka):
        <span class="kw">return</span> getattr(app(), name)(*a, **ka)

    <span class="kw">return</span> wrapper


route     = make_default_app_wrapper(<span class="str">'route'</span>)
get       = make_default_app_wrapper(<span class="str">'get'</span>)
post      = make_default_app_wrapper(<span class="str">'post'</span>)
put       = make_default_app_wrapper(<span class="str">'put'</span>)
delete    = make_default_app_wrapper(<span class="str">'delete'</span>)
patch     = make_default_app_wrapper(<span class="str">'patch'</span>)
error     = make_default_app_wrapper(<span class="str">'error'</span>)
mount     = make_default_app_wrapper(<span class="str">'mount'</span>)
hook      = make_default_app_wrapper(<span class="str">'hook'</span>)
install   = make_default_app_wrapper(<span class="str">'install'</span>)
uninstall = make_default_app_wrapper(<span class="str">'uninstall'</span>)
url       = make_default_app_wrapper(<span class="str">'get_url'</span>)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Server Adapter ###############################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> ServerAdapter(object):
    quiet = False

    <span class="kw">def</span> __init__(self, host=<span class="str">'127.0.0.1'</span>, port=<span class="dig">8080</span>, **options):
        self.options = options
        self.host = host
        self.port = int(port)

    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">pass</span>

    <span class="kw">def</span> __repr__(self):
        args = <span class="str">', '</span>.join([<span class="str">'%s=%s'</span> % (k, repr(v))
                          <span class="kw">for</span> k, v <span class="kw">in</span> self.options.items()])
        <span class="kw">return</span> <span class="str">"%s(%s)"</span> % (self.__class__.__name__, args)


<span class="kw">class</span> CGIServer(ServerAdapter):
    quiet = True

    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">from</span> wsgiref.handlers <span class="kw">import</span> CGIHandler

        <span class="kw">def</span> fixed_environ(environ, start_response):
            environ.setdefault(<span class="str">'PATH_INFO'</span>, <span class="str">''</span>)
            <span class="kw">return</span> handler(environ, start_response)

        CGIHandler().run(fixed_environ)


<span class="kw">class</span> FlupFCGIServer(ServerAdapter):
    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">import</span> flup.server.fcgi
        self.options.setdefault(<span class="str">'bindAddress'</span>, (self.host, self.port))
        flup.server.fcgi.WSGIServer(handler, **self.options).run()


<span class="kw">class</span> WSGIRefServer(ServerAdapter):
    <span class="kw">def</span> run(self, app):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">from</span> wsgiref.simple_server <span class="kw">import</span> make_server
        <span class="kw">from</span> wsgiref.simple_server <span class="kw">import</span> WSGIRequestHandler, WSGIServer
        <span class="kw">import</span> socket

        <span class="kw">class</span> FixedHandler(WSGIRequestHandler):
            <span class="kw">def</span> address_string(self):  <span class="cmt"># Prevent reverse DNS lookups please.</span>
                <span class="kw">return</span> self.client_address[<span class="dig">0</span>]

            <span class="kw">def</span> log_request(*args, **kw):
                <span class="kw">if</span> <span class="kw">not</span> self.quiet:
                    <span class="kw">return</span> WSGIRequestHandler.log_request(*args, **kw)

        handler_cls = self.options.get(<span class="str">'handler_class'</span>, FixedHandler)
        server_cls = self.options.get(<span class="str">'server_class'</span>, WSGIServer)

        <span class="kw">if</span> <span class="str">':'</span> <span class="kw">in</span> self.host:  <span class="cmt"># Fix wsgiref for IPv6 addresses.</span>
            <span class="kw">if</span> getattr(server_cls, <span class="str">'address_family'</span>) == socket.AF_INET:

                <span class="kw">class</span> server_cls(server_cls):
                    address_family = socket.AF_INET6

        self.srv = make_server(self.host, self.port, app, server_cls,
                               handler_cls)
        self.port = self.srv.server_port  <span class="cmt"># update port actual port (0 means random)</span>
        <span class="kw">try</span>:
            self.srv.serve_forever()
        <span class="kw">except</span> KeyboardInterrupt:
            self.srv.server_close()  <span class="cmt"># Prevent ResourceWarning: unclosed socket</span>
            <span class="kw">raise</span>


<span class="kw">class</span> CherryPyServer(ServerAdapter):
    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">from</span> cherrypy <span class="kw">import</span> wsgiserver
        self.options[<span class="str">'bind_addr'</span>] = (self.host, self.port)
        self.options[<span class="str">'wsgi_app'</span>] = handler

        certfile = self.options.get(<span class="str">'certfile'</span>)
        <span class="kw">if</span> certfile:
            <span class="kw">del</span> self.options[<span class="str">'certfile'</span>]
        keyfile = self.options.get(<span class="str">'keyfile'</span>)
        <span class="kw">if</span> keyfile:
            <span class="kw">del</span> self.options[<span class="str">'keyfile'</span>]

        server = wsgiserver.CherryPyWSGIServer(**self.options)
        <span class="kw">if</span> certfile:
            server.ssl_certificate = certfile
        <span class="kw">if</span> keyfile:
            server.ssl_private_key = keyfile

        <span class="kw">try</span>:
            server.start()
        <span class="kw">finally</span>:
            server.stop()


<span class="kw">class</span> WaitressServer(ServerAdapter):
    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> waitress <span class="kw">import</span> serve
        serve(handler, host=self.host, port=self.port, _quiet=self.quiet)


<span class="kw">class</span> PasteServer(ServerAdapter):
    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">from</span> paste <span class="kw">import</span> httpserver
        <span class="kw">from</span> paste.translogger <span class="kw">import</span> TransLogger
        handler = TransLogger(handler, setup_console_handler=(<span class="kw">not</span> self.quiet))
        httpserver.serve(handler,
                         host=self.host,
                         port=str(self.port), **self.options)


<span class="kw">class</span> MeinheldServer(ServerAdapter):
    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> meinheld <span class="kw">import</span> server
        server.listen((self.host, self.port))
        server.run(handler)


<span class="kw">class</span> FapwsServer(ServerAdapter):
    <span class="str">""" Extremely fast webserver using libev. See http://www.fapws.org/ """</span>

    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">import</span> fapws._evwsgi <span class="kw">as</span> evwsgi
        <span class="kw">from</span> fapws <span class="kw">import</span> base, config
        port = self.port
        <span class="kw">if</span> float(config.SERVER_IDENT[-<span class="dig">2</span>:]) &gt; <span class="dig">0.4</span>:
            <span class="cmt"># fapws3 silently changed its API in 0.5</span>
            port = str(port)
        evwsgi.start(self.host, port)
        <span class="cmt"># fapws3 never releases the GIL. Complain upstream. I tried. No luck.</span>
        <span class="kw">if</span> <span class="str">'BOTTLE_CHILD'</span> <span class="kw">in</span> os.environ <span class="kw">and</span> <span class="kw">not</span> self.quiet:
            _stderr(<span class="str">"WARNING: Auto-reloading does not work with Fapws3.\n"</span>)
            _stderr(<span class="str">"         (Fapws3 breaks python thread support)\n"</span>)
        evwsgi.set_base_module(base)

        <span class="kw">def</span> app(environ, start_response):
            environ[<span class="str">'wsgi.multiprocess'</span>] = False
            <span class="kw">return</span> handler(environ, start_response)

        evwsgi.wsgi_cb((<span class="str">''</span>, app))
        evwsgi.run()


<span class="kw">class</span> TornadoServer(ServerAdapter):
    <span class="str">""" The super hyped asynchronous server by facebook. Untested. """</span>

    <span class="kw">def</span> run(self, handler):  <span class="cmt"># pragma: no cover</span>
        <span class="kw">import</span> tornado.wsgi, tornado.httpserver, tornado.ioloop
        container = tornado.wsgi.WSGIContainer(handler)
        server = tornado.httpserver.HTTPServer(container)
        server.listen(port=self.port, address=self.host)
        tornado.ioloop.IOLoop.instance().start()


<span class="kw">class</span> AppEngineServer(ServerAdapter):
    <span class="str">""" Adapter for Google App Engine. """</span>
    quiet = True

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> google.appengine.ext.webapp <span class="kw">import</span> util
        <span class="cmt"># A main() function in the handler script enables 'App Caching'.</span>
        <span class="cmt"># Lets makes sure it is there. This _really_ improves performance.</span>
        module = sys.modules.get(<span class="str">'__main__'</span>)
        <span class="kw">if</span> module <span class="kw">and</span> <span class="kw">not</span> hasattr(module, <span class="str">'main'</span>):
            module.main = <span class="kw">lambda</span>: util.run_wsgi_app(handler)
        util.run_wsgi_app(handler)


<span class="kw">class</span> TwistedServer(ServerAdapter):
    <span class="str">""" Untested. """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> twisted.web <span class="kw">import</span> server, wsgi
        <span class="kw">from</span> twisted.python.threadpool <span class="kw">import</span> ThreadPool
        <span class="kw">from</span> twisted.internet <span class="kw">import</span> reactor
        thread_pool = ThreadPool()
        thread_pool.start()
        reactor.addSystemEventTrigger(<span class="str">'after'</span>, <span class="str">'shutdown'</span>, thread_pool.stop)
        factory = server.Site(wsgi.WSGIResource(reactor, thread_pool, handler))
        reactor.listenTCP(self.port, factory, interface=self.host)
        <span class="kw">if</span> <span class="kw">not</span> reactor.running:
            reactor.run()


<span class="kw">class</span> DieselServer(ServerAdapter):
    <span class="str">""" Untested. """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> diesel.protocols.wsgi <span class="kw">import</span> WSGIApplication
        app = WSGIApplication(handler, port=self.port)
        app.run()


<span class="kw">class</span> GeventServer(ServerAdapter):
    <span class="str">""" Untested. Options:

        * `fast` (default: False) uses libevent's http server, but has some
          issues: No streaming, no pipelining, no SSL.
        * See gevent.wsgi.WSGIServer() documentation for more options.
    """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> gevent <span class="kw">import</span> wsgi, pywsgi, local
        <span class="kw">if</span> <span class="kw">not</span> isinstance(threading.local(), local.local):
            msg = <span class="str">"Bottle requires gevent.monkey.patch_all() (before import)"</span>
            <span class="kw">raise</span> RuntimeError(msg)
        <span class="kw">if</span> <span class="kw">not</span> self.options.pop(<span class="str">'fast'</span>, None): wsgi = pywsgi
        self.options[<span class="str">'log'</span>] = None <span class="kw">if</span> self.quiet <span class="kw">else</span> <span class="str">'default'</span>
        address = (self.host, self.port)
        server = wsgi.WSGIServer(address, handler, **self.options)
        <span class="kw">if</span> <span class="str">'BOTTLE_CHILD'</span> <span class="kw">in</span> os.environ:
            <span class="kw">import</span> signal
            signal.signal(signal.SIGINT, <span class="kw">lambda</span> s, f: server.stop())
        server.serve_forever()


<span class="kw">class</span> GeventSocketIOServer(ServerAdapter):
    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> socketio <span class="kw">import</span> server
        address = (self.host, self.port)
        server.SocketIOServer(address, handler, **self.options).serve_forever()


<span class="kw">class</span> GunicornServer(ServerAdapter):
    <span class="str">""" Untested. See http://gunicorn.org/configure.html for options. """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> gunicorn.app.base <span class="kw">import</span> Application

        config = {<span class="str">'bind'</span>: <span class="str">"%s:%d"</span> % (self.host, int(self.port))}
        config.update(self.options)

        <span class="kw">class</span> GunicornApplication(Application):
            <span class="kw">def</span> init(self, parser, opts, args):
                <span class="kw">return</span> config

            <span class="kw">def</span> load(self):
                <span class="kw">return</span> handler

        GunicornApplication().run()


<span class="kw">class</span> EventletServer(ServerAdapter):
    <span class="str">""" Untested. Options:

        * `backlog` adjust the eventlet backlog parameter which is the maximum
          number of queued connections. Should be at least 1; the maximum
          value is system-dependent.
        * `family`: (default is 2) socket family, optional. See socket
          documentation for available families.
    """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> eventlet <span class="kw">import</span> wsgi, listen, patcher
        <span class="kw">if</span> <span class="kw">not</span> patcher.is_monkey_patched(os):
            msg = <span class="str">"Bottle requires eventlet.monkey_patch() (before import)"</span>
            <span class="kw">raise</span> RuntimeError(msg)
        socket_args = {}
        <span class="kw">for</span> arg <span class="kw">in</span> (<span class="str">'backlog'</span>, <span class="str">'family'</span>):
            <span class="kw">try</span>:
                socket_args[arg] = self.options.pop(arg)
            <span class="kw">except</span> KeyError:
                <span class="kw">pass</span>
        address = (self.host, self.port)
        <span class="kw">try</span>:
            wsgi.server(listen(address, **socket_args), handler,
                        log_output=(<span class="kw">not</span> self.quiet))
        <span class="kw">except</span> TypeError:
            <span class="cmt"># Fallback, if we have old version of eventlet</span>
            wsgi.server(listen(address), handler)


<span class="kw">class</span> RocketServer(ServerAdapter):
    <span class="str">""" Untested. """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> rocket <span class="kw">import</span> Rocket
        server = Rocket((self.host, self.port), <span class="str">'wsgi'</span>, {<span class="str">'wsgi_app'</span>: handler})
        server.start()


<span class="kw">class</span> BjoernServer(ServerAdapter):
    <span class="str">""" Fast server written in C: https://github.com/jonashaag/bjoern """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">from</span> bjoern <span class="kw">import</span> run
        run(handler, self.host, self.port)


<span class="kw">class</span> AiohttpServer(ServerAdapter):
    <span class="str">""" Untested.
        aiohttp
        https://pypi.python.org/pypi/aiohttp/
    """</span>

    <span class="kw">def</span> run(self, handler):
        <span class="kw">import</span> asyncio
        <span class="kw">from</span> aiohttp.wsgi <span class="kw">import</span> WSGIServerHttpProtocol
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

        protocol_factory = <span class="kw">lambda</span>: WSGIServerHttpProtocol(
            handler,
            readpayload=True,
            debug=(<span class="kw">not</span> self.quiet))
        self.loop.run_until_complete(self.loop.create_server(protocol_factory,
                                                             self.host,
                                                             self.port))

        <span class="kw">if</span> <span class="str">'BOTTLE_CHILD'</span> <span class="kw">in</span> os.environ:
            <span class="kw">import</span> signal
            signal.signal(signal.SIGINT, <span class="kw">lambda</span> s, f: self.loop.stop())

        <span class="kw">try</span>:
            self.loop.run_forever()
        <span class="kw">except</span> KeyboardInterrupt:
            self.loop.stop()


<span class="kw">class</span> AutoServer(ServerAdapter):
    <span class="str">""" Untested. """</span>
    adapters = [WaitressServer, PasteServer, TwistedServer, CherryPyServer,
                WSGIRefServer]

    <span class="kw">def</span> run(self, handler):
        <span class="kw">for</span> sa <span class="kw">in</span> self.adapters:
            <span class="kw">try</span>:
                <span class="kw">return</span> sa(self.host, self.port, **self.options).run(handler)
            <span class="kw">except</span> ImportError:
                <span class="kw">pass</span>


server_names = {
    <span class="str">'cgi'</span>: CGIServer,
    <span class="str">'flup'</span>: FlupFCGIServer,
    <span class="str">'wsgiref'</span>: WSGIRefServer,
    <span class="str">'waitress'</span>: WaitressServer,
    <span class="str">'cherrypy'</span>: CherryPyServer,
    <span class="str">'paste'</span>: PasteServer,
    <span class="str">'fapws3'</span>: FapwsServer,
    <span class="str">'tornado'</span>: TornadoServer,
    <span class="str">'gae'</span>: AppEngineServer,
    <span class="str">'twisted'</span>: TwistedServer,
    <span class="str">'diesel'</span>: DieselServer,
    <span class="str">'meinheld'</span>: MeinheldServer,
    <span class="str">'gunicorn'</span>: GunicornServer,
    <span class="str">'eventlet'</span>: EventletServer,
    <span class="str">'gevent'</span>: GeventServer,
    <span class="str">'geventSocketIO'</span>: GeventSocketIOServer,
    <span class="str">'rocket'</span>: RocketServer,
    <span class="str">'bjoern'</span>: BjoernServer,
    <span class="str">'aiohttp'</span>: AiohttpServer,
    <span class="str">'auto'</span>: AutoServer,
}

<span class="cmt">###############################################################################</span>
<span class="cmt"># Application Control ##########################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">def</span> load(target, **namespace):
    <span class="str">""" Import a module or fetch an object from a module.

        * ``package.module`` returns `module` as a module object.
        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`.
        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result.

        The last form accepts not only function calls, but any type of
        expression. Keyword arguments passed to this function are available as
        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')``
    """</span>
    module, target = target.split(<span class="str">":"</span>, <span class="dig">1</span>) <span class="kw">if</span> <span class="str">':'</span> <span class="kw">in</span> target <span class="kw">else</span> (target, None)
    <span class="kw">if</span> module <span class="kw">not</span> <span class="kw">in</span> sys.modules: __import__(module)
    <span class="kw">if</span> <span class="kw">not</span> target: <span class="kw">return</span> sys.modules[module]
    <span class="kw">if</span> target.isalnum(): <span class="kw">return</span> getattr(sys.modules[module], target)
    package_name = module.split(<span class="str">'.'</span>)[<span class="dig">0</span>]
    namespace[package_name] = sys.modules[package_name]
    <span class="kw">return</span> eval(<span class="str">'%s.%s'</span> % (module, target), namespace)


<span class="kw">def</span> load_app(target):
    <span class="str">""" Load a bottle application from a module and make sure that the import
        does not affect the current default application, but returns a separate
        application object. See :func:`load` for the target parameter. """</span>
    <span class="kw">global</span> NORUN
    NORUN, nr_old = True, NORUN
    tmp = default_app.push()  <span class="cmt"># Create a new "default application"</span>
    <span class="kw">try</span>:
        rv = load(target)  <span class="cmt"># Import the target module</span>
        <span class="kw">return</span> rv <span class="kw">if</span> callable(rv) <span class="kw">else</span> tmp
    <span class="kw">finally</span>:
        default_app.remove(tmp)  <span class="cmt"># Remove the temporary added default application</span>
        NORUN = nr_old


_debug = debug


<span class="kw">def</span> run(app=None,
        server=<span class="str">'wsgiref'</span>,
        host=<span class="str">'127.0.0.1'</span>,
        port=<span class="dig">8080</span>,
        interval=<span class="dig">1</span>,
        reloader=False,
        quiet=False,
        plugins=None,
        debug=None,
        config=None, **kargs):
    <span class="str">""" Start a server instance. This method blocks until the server terminates.

        :param app: WSGI application or target string supported by
               :func:`load_app`. (default: :func:`default_app`)
        :param server: Server adapter to use. See :data:`server_names` keys
               for valid names or pass a :class:`ServerAdapter` subclass.
               (default: `wsgiref`)
        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on
               all interfaces including the external one. (default: 127.0.0.1)
        :param port: Server port to bind to. Values below 1024 require root
               privileges. (default: 8080)
        :param reloader: Start auto-reloading server? (default: False)
        :param interval: Auto-reloader interval in seconds (default: 1)
        :param quiet: Suppress output to stdout and stderr? (default: False)
        :param options: Options passed to the server adapter.
     """</span>
    <span class="kw">if</span> NORUN: <span class="kw">return</span>
    <span class="kw">if</span> reloader <span class="kw">and</span> <span class="kw">not</span> os.environ.get(<span class="str">'BOTTLE_CHILD'</span>):
        <span class="kw">import</span> subprocess
        lockfile = None
        <span class="kw">try</span>:
            fd, lockfile = tempfile.mkstemp(prefix=<span class="str">'bottle.'</span>, suffix=<span class="str">'.lock'</span>)
            os.close(fd)  <span class="cmt"># We only need this file to exist. We never write to it</span>
            <span class="kw">while</span> os.path.exists(lockfile):
                args = [sys.executable] + sys.argv
                environ = os.environ.copy()
                environ[<span class="str">'BOTTLE_CHILD'</span>] = <span class="str">'true'</span>
                environ[<span class="str">'BOTTLE_LOCKFILE'</span>] = lockfile
                p = subprocess.Popen(args, env=environ)
                <span class="kw">while</span> p.poll() <span class="kw">is</span> None:  <span class="cmt"># Busy wait...</span>
                    os.utime(lockfile, None)  <span class="cmt"># I am alive!</span>
                    time.<span class="skw">sleep</span>(interval)
                <span class="kw">if</span> p.poll() != <span class="dig">3</span>:
                    <span class="kw">if</span> os.path.exists(lockfile): os.unlink(lockfile)
                    sys.exit(p.poll())
        <span class="kw">except</span> KeyboardInterrupt:
            <span class="kw">pass</span>
        <span class="kw">finally</span>:
            <span class="kw">if</span> os.path.exists(lockfile):
                os.unlink(lockfile)
        <span class="kw">return</span>

    <span class="kw">try</span>:
        <span class="kw">if</span> debug <span class="kw">is</span> <span class="kw">not</span> None: _debug(debug)
        app = app <span class="kw">or</span> default_app()
        <span class="kw">if</span> isinstance(app, basestring):
            app = load_app(app)
        <span class="kw">if</span> <span class="kw">not</span> callable(app):
            <span class="kw">raise</span> ValueError(<span class="str">"Application is not callable: %r"</span> % app)

        <span class="kw">for</span> plugin <span class="kw">in</span> plugins <span class="kw">or</span> []:
            <span class="kw">if</span> isinstance(plugin, basestring):
                plugin = load(plugin)
            app.install(plugin)

        <span class="kw">if</span> config:
            app.config.update(config)

        <span class="kw">if</span> server <span class="kw">in</span> server_names:
            server = server_names.get(server)
        <span class="kw">if</span> isinstance(server, basestring):
            server = load(server)
        <span class="kw">if</span> isinstance(server, <span class="skw">type</span>):
            server = server(host=host, port=port, **kargs)
        <span class="kw">if</span> <span class="kw">not</span> isinstance(server, ServerAdapter):
            <span class="kw">raise</span> ValueError(<span class="str">"Unknown or unsupported server: %r"</span> % server)

        server.quiet = server.quiet <span class="kw">or</span> quiet
        <span class="kw">if</span> <span class="kw">not</span> server.quiet:
            _stderr(<span class="str">"Bottle v%s server starting up (using %s)...\n"</span> %
                    (__version__, repr(server)))
            _stderr(<span class="str">"Listening on http://%s:%d/\n"</span> %
                    (server.host, server.port))
            _stderr(<span class="str">"Hit Ctrl-C to quit.\n\n"</span>)

        <span class="kw">if</span> reloader:
            lockfile = os.environ.get(<span class="str">'BOTTLE_LOCKFILE'</span>)
            bgcheck = FileCheckerThread(lockfile, interval)
            <span class="kw">with</span> bgcheck:
                server.run(app)
            <span class="kw">if</span> bgcheck.status == <span class="str">'reload'</span>:
                sys.exit(<span class="dig">3</span>)
        <span class="kw">else</span>:
            server.run(app)
    <span class="kw">except</span> KeyboardInterrupt:
        <span class="kw">pass</span>
    <span class="kw">except</span> (SystemExit, MemoryError):
        <span class="kw">raise</span>
    <span class="kw">except</span>:
        <span class="kw">if</span> <span class="kw">not</span> reloader: <span class="kw">raise</span>
        <span class="kw">if</span> <span class="kw">not</span> getattr(server, <span class="str">'quiet'</span>, quiet):
            print_exc()
        time.<span class="skw">sleep</span>(interval)
        sys.exit(<span class="dig">3</span>)


<span class="kw">class</span> FileCheckerThread(threading.Thread):
    <span class="str">""" Interrupt main-thread as soon as a changed module file is detected,
        the lockfile gets deleted or gets too old. """</span>

    <span class="kw">def</span> __init__(self, lockfile, interval):
        threading.Thread.__init__(self)
        self.daemon = True
        self.lockfile, self.interval = lockfile, interval
        <span class="cmt">#: Is one of 'reload', 'error' or 'exit'</span>
        self.status = None

    <span class="kw">def</span> run(self):
        exists = os.path.exists
        mtime = <span class="kw">lambda</span> p: os.stat(p).st_mtime
        files = dict()

        <span class="kw">for</span> module <span class="kw">in</span> list(sys.modules.values()):
            path = getattr(module, <span class="str">'__file__'</span>, <span class="str">''</span>)
            <span class="kw">if</span> path[-<span class="dig">4</span>:] <span class="kw">in</span> (<span class="str">'.pyo'</span>, <span class="str">'.pyc'</span>): path = path[:-<span class="dig">1</span>]
            <span class="kw">if</span> path <span class="kw">and</span> exists(path): files[path] = mtime(path)

        <span class="kw">while</span> <span class="kw">not</span> self.status:
            <span class="kw">if</span> <span class="kw">not</span> exists(self.lockfile)\
            <span class="kw">or</span> mtime(self.lockfile) &lt; time.time() - self.interval - <span class="dig">5</span>:
                self.status = <span class="str">'error'</span>
                thread.interrupt_main()
            <span class="kw">for</span> path, lmtime <span class="kw">in</span> list(files.items()):
                <span class="kw">if</span> <span class="kw">not</span> exists(path) <span class="kw">or</span> mtime(path) &gt; lmtime:
                    self.status = <span class="str">'reload'</span>
                    thread.interrupt_main()
                    <span class="kw">break</span>
            time.<span class="skw">sleep</span>(self.interval)

    <span class="kw">def</span> __enter__(self):
        self.start()

    <span class="kw">def</span> __exit__(self, exc_type, *_):
        <span class="kw">if</span> <span class="kw">not</span> self.status: self.status = <span class="str">'exit'</span>  <span class="cmt"># silent exit</span>
        self.join()
        <span class="kw">return</span> exc_type <span class="kw">is</span> <span class="kw">not</span> None <span class="kw">and</span> issubclass(exc_type, KeyboardInterrupt)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Template Adapters ############################################################</span>
<span class="cmt">###############################################################################</span>


<span class="kw">class</span> TemplateError(HTTPError):
    <span class="kw">def</span> __init__(self, message):
        HTTPError.__init__(self, <span class="dig">500</span>, message)


<span class="kw">class</span> BaseTemplate(object):
    <span class="str">""" Base class and minimal API for template adapters """</span>
    extensions = [<span class="str">'tpl'</span>, <span class="str">'html'</span>, <span class="str">'thtml'</span>, <span class="str">'stpl'</span>]
    settings = {}  <span class="cmt">#used in prepare()</span>
    defaults = {}  <span class="cmt">#used in render()</span>

    <span class="kw">def</span> __init__(self,
                 source=None,
                 name=None,
                 lookup=None,
                 encoding=<span class="str">'utf8'</span>, **settings):
        <span class="str">""" Create a new template.
        If the source parameter (str or buffer) is missing, the name argument
        is used to guess a template filename. Subclasses can assume that
        self.source and/or self.filename are set. Both are strings.
        The lookup, encoding and settings parameters are stored as instance
        variables.
        The lookup parameter stores a list containing directory paths.
        The encoding parameter should be used to decode byte strings or files.
        The settings parameter contains a dict for engine-specific settings.
        """</span>
        self.name = name
        self.source = source.read() <span class="kw">if</span> hasattr(source, <span class="str">'read'</span>) <span class="kw">else</span> source
        self.filename = source.filename <span class="kw">if</span> hasattr(source, <span class="str">'filename'</span>) <span class="kw">else</span> None
        self.lookup = [os.path.abspath(x) <span class="kw">for</span> x <span class="kw">in</span> lookup] <span class="kw">if</span> lookup <span class="kw">else</span> []
        self.encoding = encoding
        self.settings = self.settings.copy()  <span class="cmt"># Copy from class variable</span>
        self.settings.update(settings)  <span class="cmt"># Apply</span>
        <span class="kw">if</span> <span class="kw">not</span> self.source <span class="kw">and</span> self.name:
            self.filename = self.search(self.name, self.lookup)
            <span class="kw">if</span> <span class="kw">not</span> self.filename:
                <span class="kw">raise</span> TemplateError(<span class="str">'Template %s not found.'</span> % repr(name))
        <span class="kw">if</span> <span class="kw">not</span> self.source <span class="kw">and</span> <span class="kw">not</span> self.filename:
            <span class="kw">raise</span> TemplateError(<span class="str">'No template specified.'</span>)
        self.prepare(**self.settings)

    @classmethod
    <span class="kw">def</span> search(cls, name, lookup=None):
        <span class="str">""" Search name in all directories specified in lookup.
        First without, then with common extensions. Return first hit. """</span>
        <span class="kw">if</span> <span class="kw">not</span> lookup:
            <span class="kw">raise</span> depr(<span class="dig">0</span>, <span class="dig">12</span>, <span class="str">"Empty template lookup path."</span>, <span class="str">"Configure a template lookup path."</span>)

        <span class="kw">if</span> os.path.isabs(name):
            <span class="kw">raise</span> depr(<span class="dig">0</span>, <span class="dig">12</span>, <span class="str">"Use of absolute path for template name."</span>,
                       <span class="str">"Refer to templates with names or paths relative to the lookup path."</span>)

        <span class="kw">for</span> spath <span class="kw">in</span> lookup:
            spath = os.path.abspath(spath) + os.sep
            fname = os.path.abspath(os.path.join(spath, name))
            <span class="kw">if</span> <span class="kw">not</span> fname.startswith(spath): <span class="kw">continue</span>
            <span class="kw">if</span> os.path.isfile(fname): <span class="kw">return</span> fname
            <span class="kw">for</span> ext <span class="kw">in</span> cls.extensions:
                <span class="kw">if</span> os.path.isfile(<span class="str">'%s.%s'</span> % (fname, ext)):
                    <span class="kw">return</span> <span class="str">'%s.%s'</span> % (fname, ext)

    @classmethod
    <span class="kw">def</span> global_config(cls, key, *args):
        <span class="str">""" This reads or sets the global settings stored in class.settings. """</span>
        <span class="kw">if</span> args:
            cls.settings = cls.settings.copy()  <span class="cmt"># Make settings local to class</span>
            cls.settings[key] = args[<span class="dig">0</span>]
        <span class="kw">else</span>:
            <span class="kw">return</span> cls.settings[key]

    <span class="kw">def</span> prepare(self, **options):
        <span class="str">""" Run preparations (parsing, caching, ...).
        It should be possible to call this again to refresh a template or to
        update settings.
        """</span>
        <span class="kw">raise</span> NotImplementedError

    <span class="kw">def</span> render(self, *args, **kwargs):
        <span class="str">""" Render the template with the specified local variables and return
        a single byte or unicode string. If it is a byte string, the encoding
        must match self.encoding. This method must be thread-safe!
        Local variables may be provided in dictionaries (args)
        or directly, as keywords (kwargs).
        """</span>
        <span class="kw">raise</span> NotImplementedError


<span class="kw">class</span> MakoTemplate(BaseTemplate):
    <span class="kw">def</span> prepare(self, **options):
        <span class="kw">from</span> mako.template <span class="kw">import</span> Template
        <span class="kw">from</span> mako.lookup <span class="kw">import</span> TemplateLookup
        options.update({<span class="str">'input_encoding'</span>: self.encoding})
        options.setdefault(<span class="str">'format_exceptions'</span>, bool(DEBUG))
        lookup = TemplateLookup(directories=self.lookup, **options)
        <span class="kw">if</span> self.source:
            self.tpl = Template(self.source, lookup=lookup, **options)
        <span class="kw">else</span>:
            self.tpl = Template(uri=self.name,
                                filename=self.filename,
                                lookup=lookup, **options)

    <span class="kw">def</span> render(self, *args, **kwargs):
        <span class="kw">for</span> dictarg <span class="kw">in</span> args:
            kwargs.update(dictarg)
        _defaults = self.defaults.copy()
        _defaults.update(kwargs)
        <span class="kw">return</span> self.tpl.render(**_defaults)


<span class="kw">class</span> CheetahTemplate(BaseTemplate):
    <span class="kw">def</span> prepare(self, **options):
        <span class="kw">from</span> Cheetah.Template <span class="kw">import</span> Template
        self.context = threading.local()
        self.context.vars = {}
        options[<span class="str">'searchList'</span>] = [self.context.vars]
        <span class="kw">if</span> self.source:
            self.tpl = Template(source=self.source, **options)
        <span class="kw">else</span>:
            self.tpl = Template(file=self.filename, **options)

    <span class="kw">def</span> render(self, *args, **kwargs):
        <span class="kw">for</span> dictarg <span class="kw">in</span> args:
            kwargs.update(dictarg)
        self.context.vars.update(self.defaults)
        self.context.vars.update(kwargs)
        out = str(self.tpl)
        self.context.vars.clear()
        <span class="kw">return</span> out


<span class="kw">class</span> Jinja2Template(BaseTemplate):
    <span class="kw">def</span> prepare(self, filters=None, tests=None, globals={}, **kwargs):
        <span class="kw">from</span> jinja2 <span class="kw">import</span> Environment, FunctionLoader
        self.env = Environment(loader=FunctionLoader(self.loader), **kwargs)
        <span class="kw">if</span> filters: self.env.filters.update(filters)
        <span class="kw">if</span> tests: self.env.tests.update(tests)
        <span class="kw">if</span> globals: self.env.globals.update(globals)
        <span class="kw">if</span> self.source:
            self.tpl = self.env.from_string(self.source)
        <span class="kw">else</span>:
            self.tpl = self.env.get_template(self.filename)

    <span class="kw">def</span> render(self, *args, **kwargs):
        <span class="kw">for</span> dictarg <span class="kw">in</span> args:
            kwargs.update(dictarg)
        _defaults = self.defaults.copy()
        _defaults.update(kwargs)
        <span class="kw">return</span> self.tpl.render(**_defaults)

    <span class="kw">def</span> loader(self, name):
        <span class="kw">if</span> name == self.filename:
            fname = name
        <span class="kw">else</span>:
            fname = self.search(name, self.lookup)
        <span class="kw">if</span> <span class="kw">not</span> fname: <span class="kw">return</span>
        <span class="kw">with</span> open(fname, <span class="str">"rb"</span>) <span class="kw">as</span> f:
            <span class="kw">return</span> f.read().decode(self.encoding)


<span class="kw">class</span> SimpleTemplate(BaseTemplate):
    <span class="kw">def</span> prepare(self,
                escape_func=html_escape,
                noescape=False,
                syntax=None, **ka):
        self.cache = {}
        enc = self.encoding
        self._str = <span class="kw">lambda</span> x: touni(x, enc)
        self._escape = <span class="kw">lambda</span> x: escape_func(touni(x, enc))
        self.syntax = syntax
        <span class="kw">if</span> noescape:
            self._str, self._escape = self._escape, self._str

    @cached_property
    <span class="kw">def</span> co(self):
        <span class="kw">return</span> compile(self.code, self.filename <span class="kw">or</span> <span class="str">'&lt;string&gt;'</span>, <span class="str">'exec'</span>)

    @cached_property
    <span class="kw">def</span> code(self):
        source = self.source
        <span class="kw">if</span> <span class="kw">not</span> source:
            <span class="kw">with</span> open(self.filename, <span class="str">'rb'</span>) <span class="kw">as</span> f:
                source = f.read()
        <span class="kw">try</span>:
            source, encoding = touni(source), <span class="str">'utf8'</span>
        <span class="kw">except</span> UnicodeError:
            <span class="kw">raise</span> depr(<span class="dig">0</span>, <span class="dig">11</span>, <span class="str">'Unsupported template encodings.'</span>, <span class="str">'Use utf-8 for templates.'</span>)
        parser = StplParser(source, encoding=encoding, syntax=self.syntax)
        code = parser.translate()
        self.encoding = parser.encoding
        <span class="kw">return</span> code

    <span class="kw">def</span> _rebase(self, _env, _name=None, **kwargs):
        _env[<span class="str">'_rebase'</span>] = (_name, kwargs)

    <span class="kw">def</span> _include(self, _env, _name=None, **kwargs):
        env = _env.copy()
        env.update(kwargs)
        <span class="kw">if</span> _name <span class="kw">not</span> <span class="kw">in</span> self.cache:
            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup)
        <span class="kw">return</span> self.cache[_name].execute(env[<span class="str">'_stdout'</span>], env)

    <span class="kw">def</span> execute(self, _stdout, kwargs):
        env = self.defaults.copy()
        env.update(kwargs)
        env.update({
            <span class="str">'_stdout'</span>: _stdout,
            <span class="str">'_printlist'</span>: _stdout.extend,
            <span class="str">'include'</span>: functools.partial(self._include, env),
            <span class="str">'rebase'</span>: functools.partial(self._rebase, env),
            <span class="str">'_rebase'</span>: None,
            <span class="str">'_str'</span>: self._str,
            <span class="str">'_escape'</span>: self._escape,
            <span class="str">'get'</span>: env.get,
            <span class="str">'setdefault'</span>: env.setdefault,
            <span class="str">'defined'</span>: env.__contains__
        })
        eval(self.co, env)
        <span class="kw">if</span> env.get(<span class="str">'_rebase'</span>):
            subtpl, rargs = env.pop(<span class="str">'_rebase'</span>)
            rargs[<span class="str">'base'</span>] = <span class="str">''</span>.join(_stdout)  <span class="cmt">#copy stdout</span>
            <span class="kw">del</span> _stdout[:]  <span class="cmt"># clear stdout</span>
            <span class="kw">return</span> self._include(env, subtpl, **rargs)
        <span class="kw">return</span> env

    <span class="kw">def</span> render(self, *args, **kwargs):
        <span class="str">""" Render the template using keyword arguments as local variables. """</span>
        env = {}
        stdout = []
        <span class="kw">for</span> dictarg <span class="kw">in</span> args:
            env.update(dictarg)
        env.update(kwargs)
        self.execute(stdout, env)
        <span class="kw">return</span> <span class="str">''</span>.join(stdout)


<span class="kw">class</span> StplSyntaxError(TemplateError):

    <span class="kw">pass</span>


<span class="kw">class</span> StplParser(object):
    <span class="str">""" Parser for stpl templates. """</span>
    _re_cache = {}  <span class="cmt">#: Cache for compiled re patterns</span>

    <span class="cmt"># This huge pile of voodoo magic splits python code into 8 different tokens.</span>
    <span class="cmt"># We use the verbose (?x) regex mode to make this more manageable</span>

    _re_tok = _re_inl = <span class="str">r'''((?mx)         # verbose and dot-matches-newline mode
        [urbURB]*
        (?:  ''(?!')
            |""(?!")
            |'{6}
            |"{6}
            |'(?:[^\\']|\\.)+?'
            |"(?:[^\\"]|\\.)+?"
            |'{3}(?:[^\\]|\\.|\n)+?'{3}
            |"{3}(?:[^\\]|\\.|\n)+?"{3}
        )
    )'''</span>

    _re_inl = _re_tok.replace(<span class="str">r'|\n'</span>, <span class="str">''</span>)  <span class="cmt"># We re-use this string pattern later</span>

    _re_tok += <span class="str">r'''
        # 2: Comments (until end of line, but not the newline itself)
        |(\#.*)

        # 3: Open and close (4) grouping tokens
        |([\[\{\(])
        |([\]\}\)])

        # 5,6: Keywords that start or continue a python block (only start of line)
        |^([\ \t]*(?:if|for|while|with|try|def|class)\b)
        |^([\ \t]*(?:elif|else|except|finally)\b)

        # 7: Our special 'end' keyword (but only if it stands alone)
        |((?:^|;)[\ \t]*end[\ \t]*(?=(?:%(block_close)s[\ \t]*)?\r?$|;|\#))

        # 8: A customizable end-of-code-block template token (only end of line)
        |(%(block_close)s[\ \t]*(?=\r?$))

        # 9: And finally, a single newline. The 10th token is 'everything else'
        |(\r?\n)
    '''</span>

    <span class="cmt"># Match the start tokens of code areas in a template</span>
    _re_split = <span class="str">r'''(?m)^[ \t]*(\\?)((%(line_start)s)|(%(block_start)s))'''</span>
    <span class="cmt"># Match inline statements (may contain python strings)</span>
    _re_inl = <span class="str">r'''%%(inline_start)s((?:%s|[^'"\n]+?)*?)%%(inline_end)s'''</span> % _re_inl

    default_syntax = <span class="str">'&lt;% %&gt; % {{ }}'</span>

    <span class="kw">def</span> __init__(self, source, syntax=None, encoding=<span class="str">'utf8'</span>):
        self.source, self.encoding = touni(source, encoding), encoding
        self.set_syntax(syntax <span class="kw">or</span> self.default_syntax)
        self.code_buffer, self.text_buffer = [], []
        self.lineno, self.offset = <span class="dig">1</span>, <span class="dig">0</span>
        self.indent, self.indent_mod = <span class="dig">0</span>, <span class="dig">0</span>
        self.paren_depth = <span class="dig">0</span>

    <span class="kw">def</span> get_syntax(self):
        <span class="str">""" Tokens as a space separated string (default: &lt;% %&gt; % {{ }}) """</span>
        <span class="kw">return</span> self._syntax

    <span class="kw">def</span> set_syntax(self, syntax):
        self._syntax = syntax
        self._tokens = syntax.split()
        <span class="kw">if</span> <span class="kw">not</span> syntax <span class="kw">in</span> self._re_cache:
            names = <span class="str">'block_start block_close line_start inline_start inline_end'</span>
            etokens = map(re.escape, self._tokens)
            pattern_vars = dict(zip(names.split(), etokens))
            patterns = (self._re_split, self._re_tok, self._re_inl)
            patterns = [re.compile(p % pattern_vars) <span class="kw">for</span> p <span class="kw">in</span> patterns]
            self._re_cache[syntax] = patterns
        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]

    syntax = property(get_syntax, set_syntax)

    <span class="kw">def</span> translate(self):
        <span class="kw">if</span> self.offset: <span class="kw">raise</span> RuntimeError(<span class="str">'Parser is a one time instance.'</span>)
        <span class="kw">while</span> True:
            m = self.re_split.search(self.source, pos=self.offset)
            <span class="kw">if</span> m:
                text = self.source[self.offset:m.start()]
                self.text_buffer.append(text)
                self.offset = m.end()
                <span class="kw">if</span> m.group(<span class="dig">1</span>):  <span class="cmt"># Escape syntax</span>
                    line, sep, _ = self.source[self.offset:].partition(<span class="str">'\n'</span>)
                    self.text_buffer.append(self.source[m.start():m.start(<span class="dig">1</span>)] +
                                            m.group(<span class="dig">2</span>) + line + sep)
                    self.offset += len(line + sep)
                    <span class="kw">continue</span>
                self.flush_text()
                self.offset += self.read_code(self.source[self.offset:],
                                              multiline=bool(m.group(<span class="dig">4</span>)))
            <span class="kw">else</span>:
                <span class="kw">break</span>
        self.text_buffer.append(self.source[self.offset:])
        self.flush_text()
        <span class="kw">return</span> <span class="str">''</span>.join(self.code_buffer)

    <span class="kw">def</span> read_code(self, pysource, multiline):
        code_line, comment = <span class="str">''</span>, <span class="str">''</span>
        offset = <span class="dig">0</span>
        <span class="kw">while</span> True:
            m = self.re_tok.search(pysource, pos=offset)
            <span class="kw">if</span> <span class="kw">not</span> m:
                code_line += pysource[offset:]
                offset = len(pysource)
                self.write_code(code_line.strip(), comment)
                <span class="kw">break</span>
            code_line += pysource[offset:m.start()]
            offset = m.end()
            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()
            <span class="kw">if</span> self.paren_depth &gt; <span class="dig">0</span> <span class="kw">and</span> (_blk1 <span class="kw">or</span> _blk2):  <span class="cmt"># a if b else c</span>
                code_line += _blk1 <span class="kw">or</span> _blk2
                <span class="kw">continue</span>
            <span class="kw">if</span> _str:  <span class="cmt"># Python string</span>
                code_line += _str
            <span class="kw">elif</span> _com:  <span class="cmt"># Python comment (up to EOL)</span>
                comment = _com
                <span class="kw">if</span> multiline <span class="kw">and</span> _com.strip().endswith(self._tokens[<span class="dig">1</span>]):
                    multiline = False  <span class="cmt"># Allow end-of-block in comments</span>
            <span class="kw">elif</span> _po:  <span class="cmt"># open parenthesis</span>
                self.paren_depth += <span class="dig">1</span>
                code_line += _po
            <span class="kw">elif</span> _pc:  <span class="cmt"># close parenthesis</span>
                <span class="kw">if</span> self.paren_depth &gt; <span class="dig">0</span>:
                    <span class="cmt"># we could check for matching parentheses here, but it's</span>
                    <span class="cmt"># easier to leave that to python - just check counts</span>
                    self.paren_depth -= <span class="dig">1</span>
                code_line += _pc
            <span class="kw">elif</span> _blk1:  <span class="cmt"># Start-block keyword (if/for/while/def/try/...)</span>
                code_line, self.indent_mod = _blk1, -<span class="dig">1</span>
                self.indent += <span class="dig">1</span>
            <span class="kw">elif</span> _blk2:  <span class="cmt"># Continue-block keyword (else/elif/except/...)</span>
                code_line, self.indent_mod = _blk2, -<span class="dig">1</span>
            <span class="kw">elif</span> _end:  <span class="cmt"># The non-standard 'end'-keyword (ends a block)</span>
                self.indent -= <span class="dig">1</span>
            <span class="kw">elif</span> _cend:  <span class="cmt"># The end-code-block template token (usually '%&gt;')</span>
                <span class="kw">if</span> multiline: multiline = False
                <span class="kw">else</span>: code_line += _cend
            <span class="kw">else</span>:  <span class="cmt"># \n</span>
                self.write_code(code_line.strip(), comment)
                self.lineno += <span class="dig">1</span>
                code_line, comment, self.indent_mod = <span class="str">''</span>, <span class="str">''</span>, <span class="dig">0</span>
                <span class="kw">if</span> <span class="kw">not</span> multiline:
                    <span class="kw">break</span>

        <span class="kw">return</span> offset

    <span class="kw">def</span> flush_text(self):
        text = <span class="str">''</span>.join(self.text_buffer)
        <span class="kw">del</span> self.text_buffer[:]
        <span class="kw">if</span> <span class="kw">not</span> text: <span class="kw">return</span>
        parts, pos, nl = [], <span class="dig">0</span>, <span class="str">'\\\n'</span> + <span class="str">'  '</span> * self.indent
        <span class="kw">for</span> m <span class="kw">in</span> self.re_inl.finditer(text):
            prefix, pos = text[pos:m.start()], m.end()
            <span class="kw">if</span> prefix:
                parts.append(nl.join(map(repr, prefix.splitlines(True))))
            <span class="kw">if</span> prefix.endswith(<span class="str">'\n'</span>): parts[-<span class="dig">1</span>] += nl
            parts.append(self.process_inline(m.group(<span class="dig">1</span>).strip()))
        <span class="kw">if</span> pos &lt; len(text):
            prefix = text[pos:]
            lines = prefix.splitlines(True)
            <span class="kw">if</span> lines[-<span class="dig">1</span>].endswith(<span class="str">'\\\\\n'</span>): lines[-<span class="dig">1</span>] = lines[-<span class="dig">1</span>][:-<span class="dig">3</span>]
            <span class="kw">elif</span> lines[-<span class="dig">1</span>].endswith(<span class="str">'\\\\\r\n'</span>): lines[-<span class="dig">1</span>] = lines[-<span class="dig">1</span>][:-<span class="dig">4</span>]
            parts.append(nl.join(map(repr, lines)))
        code = <span class="str">'_printlist((%s,))'</span> % <span class="str">', '</span>.join(parts)
        self.lineno += code.count(<span class="str">'\n'</span>) + <span class="dig">1</span>
        self.write_code(code)

    @staticmethod
    <span class="kw">def</span> process_inline(chunk):
        <span class="kw">if</span> chunk[<span class="dig">0</span>] == <span class="str">'!'</span>: <span class="kw">return</span> <span class="str">'_str(%s)'</span> % chunk[<span class="dig">1</span>:]
        <span class="kw">return</span> <span class="str">'_escape(%s)'</span> % chunk

    <span class="kw">def</span> write_code(self, line, comment=<span class="str">''</span>):
        code = <span class="str">'  '</span> * (self.indent + self.indent_mod)
        code += line.lstrip() + comment + <span class="str">'\n'</span>
        self.code_buffer.append(code)


<span class="kw">def</span> template(*args, **kwargs):
    <span class="str">"""
    Get a rendered template as a string iterator.
    You can use a name, a filename or a template string as first parameter.
    Template rendering arguments can be passed as dictionaries
    or directly (as keyword arguments).
    """</span>
    tpl = args[<span class="dig">0</span>] <span class="kw">if</span> args <span class="kw">else</span> None
    <span class="kw">for</span> dictarg <span class="kw">in</span> args[<span class="dig">1</span>:]:
        kwargs.update(dictarg)
    adapter = kwargs.pop(<span class="str">'template_adapter'</span>, SimpleTemplate)
    lookup = kwargs.pop(<span class="str">'template_lookup'</span>, TEMPLATE_PATH)
    tplid = (id(lookup), tpl)
    <span class="kw">if</span> tplid <span class="kw">not</span> <span class="kw">in</span> TEMPLATES <span class="kw">or</span> DEBUG:
        settings = kwargs.pop(<span class="str">'template_settings'</span>, {})
        <span class="kw">if</span> isinstance(tpl, adapter):
            TEMPLATES[tplid] = tpl
            <span class="kw">if</span> settings: TEMPLATES[tplid].prepare(**settings)
        <span class="kw">elif</span> <span class="str">"\n"</span> <span class="kw">in</span> tpl <span class="kw">or</span> <span class="str">"{"</span> <span class="kw">in</span> tpl <span class="kw">or</span> <span class="str">"%"</span> <span class="kw">in</span> tpl <span class="kw">or</span> <span class="str">'$'</span> <span class="kw">in</span> tpl:
            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)
        <span class="kw">else</span>:
            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)
    <span class="kw">if</span> <span class="kw">not</span> TEMPLATES[tplid]:
        abort(<span class="dig">500</span>, <span class="str">'Template (%s) not found'</span> % tpl)
    <span class="kw">return</span> TEMPLATES[tplid].render(kwargs)


mako_template = functools.partial(template, template_adapter=MakoTemplate)
cheetah_template = functools.partial(template,
                                     template_adapter=CheetahTemplate)
jinja2_template = functools.partial(template, template_adapter=Jinja2Template)


<span class="kw">def</span> view(tpl_name, **defaults):
    <span class="str">""" Decorator: renders a template for a handler.
        The handler can control its behavior like that:

          - return a dict of template vars to fill out the template
          - return something other than a dict and the view decorator will not
            process the template, but return the handler result as is.
            This includes returning a HTTPResponse(dict) to get,
            for instance, JSON with autojson or other castfilters.
    """</span>

    <span class="kw">def</span> decorator(func):

        @functools.wraps(func)
        <span class="kw">def</span> wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            <span class="kw">if</span> isinstance(result, (dict, DictMixin)):
                tplvars = defaults.copy()
                tplvars.update(result)
                <span class="kw">return</span> template(tpl_name, **tplvars)
            <span class="kw">elif</span> result <span class="kw">is</span> None:
                <span class="kw">return</span> template(tpl_name, defaults)
            <span class="kw">return</span> result

        <span class="kw">return</span> wrapper

    <span class="kw">return</span> decorator


mako_view = functools.partial(view, template_adapter=MakoTemplate)
cheetah_view = functools.partial(view, template_adapter=CheetahTemplate)
jinja2_view = functools.partial(view, template_adapter=Jinja2Template)

<span class="cmt">###############################################################################</span>
<span class="cmt"># Constants and Globals ########################################################</span>
<span class="cmt">###############################################################################</span>

TEMPLATE_PATH = [<span class="str">'./'</span>, <span class="str">'./views/'</span>]
TEMPLATES = {}
DEBUG = False
NORUN = False  <span class="cmt"># If set, run() does nothing. Used by load_app()</span>

<span class="cmt">#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')</span>
HTTP_CODES = httplib.responses.copy()
HTTP_CODES[<span class="dig">418</span>] = <span class="str">"I'm a teapot"</span>  <span class="cmt"># RFC 2324</span>
HTTP_CODES[<span class="dig">428</span>] = <span class="str">"Precondition Required"</span>
HTTP_CODES[<span class="dig">429</span>] = <span class="str">"Too Many Requests"</span>
HTTP_CODES[<span class="dig">431</span>] = <span class="str">"Request Header Fields Too Large"</span>
HTTP_CODES[<span class="dig">511</span>] = <span class="str">"Network Authentication Required"</span>
_HTTP_STATUS_LINES = dict((k, <span class="str">'%d %s'</span> % (k, v))
                          <span class="kw">for</span> (k, v) <span class="kw">in</span> HTTP_CODES.items())

<span class="cmt">#: The default template used for error pages. Override with @error()</span>
ERROR_PAGE_TEMPLATE = <span class="str">"""
%%try:
    %%from %s import DEBUG, request
    &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Error: {{e.status}}&lt;/title&gt;
            &lt;style type="text/css"&gt;
              html {background-color: #eee; font-family: sans-serif;}
              body {background-color: #fff; border: 1px solid #ddd;
                    padding: 15px; margin: 15px;}
              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;}
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Error: {{e.status}}&lt;/h1&gt;
            &lt;p&gt;Sorry, the requested URL &lt;tt&gt;{{repr(request.url)}}&lt;/tt&gt;
               caused an error:&lt;/p&gt;
            &lt;pre&gt;{{e.body}}&lt;/pre&gt;
            %%if DEBUG and e.exception:
              &lt;h2&gt;Exception:&lt;/h2&gt;
              &lt;pre&gt;{{repr(e.exception)}}&lt;/pre&gt;
            %%end
            %%if DEBUG and e.traceback:
              &lt;h2&gt;Traceback:&lt;/h2&gt;
              &lt;pre&gt;{{e.traceback}}&lt;/pre&gt;
            %%end
        &lt;/body&gt;
    &lt;/html&gt;
%%except ImportError:
    &lt;b&gt;ImportError:&lt;/b&gt; Could not generate the error page. Please add bottle to
    the import path.
%%end
"""</span> % __name__

<span class="cmt">#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a</span>
<span class="cmt">#: request callback, this instance always refers to the *current* request</span>
<span class="cmt">#: (even on a multi-threaded server).</span>
request = LocalRequest()

<span class="cmt">#: A thread-safe instance of :class:`LocalResponse`. It is used to change the</span>
<span class="cmt">#: HTTP response for the *current* request.</span>
response = LocalResponse()

<span class="cmt">#: A thread-safe namespace. Not used by Bottle.</span>
local = threading.local()

<span class="cmt"># Initialize app stack (create first empty Bottle app now deferred until needed)</span>
<span class="cmt"># BC: 0.6.4 and needed for run()</span>
apps = app = default_app = AppStack()


<span class="cmt">#: A virtual package that redirects import statements.</span>
<span class="cmt">#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.</span>
ext = _ImportRedirect(<span class="str">'bottle.ext'</span> <span class="kw">if</span> __name__ == <span class="str">'__main__'</span> <span class="kw">else</span>
                      __name__ + <span class="str">".ext"</span>, <span class="str">'bottle_%s'</span>).module



<span class="kw">if</span> __name__ == <span class="str">'__main__'</span>:
    opt, args, parser = _cli_parse(sys.argv)

    <span class="kw">def</span> _cli_error(msg):
        parser.print_help()
        _stderr(<span class="str">'\nError: %s\n'</span> % msg)
        sys.exit(<span class="dig">1</span>)

    <span class="kw">if</span> opt.version:
        _stdout(<span class="str">'Bottle %s\n'</span> % __version__)
        sys.exit(<span class="dig">0</span>)
    <span class="kw">if</span> <span class="kw">not</span> args:
        _cli_error(<span class="str">"No application entry point specified."</span>)

    sys.path.insert(<span class="dig">0</span>, <span class="str">'.'</span>)
    sys.modules.setdefault(<span class="str">'bottle'</span>, sys.modules[<span class="str">'__main__'</span>])

    host, port = (opt.bind <span class="kw">or</span> <span class="str">'localhost'</span>), <span class="dig">8080</span>
    <span class="kw">if</span> <span class="str">':'</span> <span class="kw">in</span> host <span class="kw">and</span> host.rfind(<span class="str">']'</span>) &lt; host.rfind(<span class="str">':'</span>):
        host, port = host.rsplit(<span class="str">':'</span>, <span class="dig">1</span>)
    host = host.strip(<span class="str">'[]'</span>)

    config = ConfigDict()

    <span class="kw">for</span> cfile <span class="kw">in</span> opt.conf <span class="kw">or</span> []:
        <span class="kw">try</span>:
            <span class="kw">if</span> cfile.endswith(<span class="str">'.json'</span>):
                <span class="kw">with</span> open(cfile, <span class="str">'rb'</span>) <span class="kw">as</span> fp:
                    config.load_dict(json_loads(fp.read()))
            <span class="kw">else</span>:
                config.load_config(cfile)
        <span class="kw">except</span> ConfigParserError:
            _cli_error(str(_e()))
        <span class="kw">except</span> IOError:
            _cli_error(<span class="str">"Unable to read config file %r"</span> % cfile)
        <span class="kw">except</span> (UnicodeError, TypeError, ValueError):
            _cli_error(<span class="str">"Unable to parse config file %r: %s"</span> % (cfile, _e()))

    <span class="kw">for</span> cval <span class="kw">in</span> opt.param <span class="kw">or</span> []:
        <span class="kw">if</span> <span class="str">'='</span> <span class="kw">in</span> cval:
            config.update((cval.split(<span class="str">'='</span>, <span class="dig">1</span>),))
        <span class="kw">else</span>:
            config[cval] = True

    run(args[<span class="dig">0</span>],
        host=host,
        port=int(port),
        server=opt.server,
        reloader=opt.reload,
        plugins=opt.plugin,
        debug=opt.debug,
        config=config)

<span class="cmt"># THE END</span>

</pre>
</body>
</html>
